<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于 2DPCA 的人脸识别方法——特征脸法[3]</title>
    <url>/%E5%9F%BA%E4%BA%8E-2DPCA-%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E7%89%B9%E5%BE%81%E8%84%B8%E6%B3%95-3/</url>
    <content><![CDATA[<h1 id="基于-2DPCA-的人脸识别方法——特征脸法-3"><a href="#基于-2DPCA-的人脸识别方法——特征脸法-3" class="headerlink" title="基于 2DPCA 的人脸识别方法——特征脸法[3]"></a>基于 2DPCA 的人脸识别方法——特征脸法[3]</h1><h2 id="2DPCA"><a href="#2DPCA" class="headerlink" title="2DPCA"></a>2DPCA</h2><p>论文：<a href="https://ieeexplore.ieee.org/abstract/document/1261097" target="_blank" rel="noopener">Two-dimensional PCA: a new approach to appearance-based face representation and recognition | IEEE Journals &amp; Magazine | IEEE Xplore</a></p>
<p>提出了 2DPCA 的方法，是对基于PCA的特征脸法的改进。该方案直接对图片本身（矩阵）进行操作，而不是像 PCA 一样，把一张图片拉成一条列向量再进行计算。这种方法显著减少了协方差矩阵的维度，减少了计算量。2DPCA 使用较少的特征向量就能够较好地对人脸进行重构。</p>
<a id="more"></a>

<h2 id="Matlab-复现"><a href="#Matlab-复现" class="headerlink" title="Matlab 复现"></a>Matlab 复现</h2><p>基本思路和 PCA 差不多，只不过一些地方有些区别。</p>
<h3 id="1-原始数据处理与划分"><a href="#1-原始数据处理与划分" class="headerlink" title="1. 原始数据处理与划分"></a>1. 原始数据处理与划分</h3><p>这里用了ORL数据集，与 PCA 相比，2DPCA 不再需要把一张脸 reshape 成一个列向量了。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 400张图，一共40人，一人10张</span></span><br><span class="line">load(<span class="string">'ORL4646.mat'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 取出前40%作为测试数据，剩下60%作为训练数据</span></span><br><span class="line">test_data_index = [];</span><br><span class="line">train_data_index = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">0</span>:<span class="number">39</span></span><br><span class="line">    test_data_index = [test_data_index <span class="number">10</span>*<span class="built_in">i</span>+<span class="number">1</span>:<span class="number">10</span>*<span class="built_in">i</span>+<span class="number">4</span>];</span><br><span class="line">    train_data_index = [train_data_index <span class="number">10</span>*<span class="built_in">i</span>+<span class="number">5</span>:<span class="number">10</span>*(<span class="built_in">i</span>+<span class="number">1</span>)];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">test_data = ORL4646(:, :, test_data_index);</span><br><span class="line">train_data = ORL4646(:, :,train_data_index);</span><br></pre></td></tr></table></figure>

<h3 id="2-求平均脸"><a href="#2-求平均脸" class="headerlink" title="2. 求平均脸"></a>2. 求平均脸</h3><p>由于 2DPCA 保留图像原矩阵，因此这里的平均脸是通过对第三维度求平均得到的。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mean_face = <span class="built_in">mean</span>(train_data, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-计算散布矩阵"><a href="#3-计算散布矩阵" class="headerlink" title="3. 计算散布矩阵"></a>3. 计算散布矩阵</h3><p>计算散布本质上和计算协方差矩阵是一样的，只是多除以一个 N-1，下图公式直接省略了 N-1，因为其对目标不会有影响。<br><img src="https://pic3.zhimg.com/80/v2-4a5a114499f97e46dd826de4610b886f_720w.png" alt="散布矩阵"><br>Xi 表示第 i 张图片（矩阵），因此这个公式实际上表示的就是：遍历每一张图片（矩阵）Xi，求出相应的值后累加。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 协方差矩阵</span></span><br><span class="line">cov_matrix = <span class="built_in">zeros</span>(<span class="number">46</span>, <span class="number">46</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">size</span>(train_data, <span class="number">3</span>)</span><br><span class="line">    centered_face = train_data(:,:,<span class="built_in">i</span>) - mean_face;</span><br><span class="line">    cov_matrix = cov_matrix + centered_face' * centered_face;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 散布矩阵</span></span><br><span class="line">scatter_matrix = cov_matrix / (<span class="built_in">size</span>(train_data, <span class="number">3</span>) - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-求散布矩阵的特征值和特征向量"><a href="#4-求散布矩阵的特征值和特征向量" class="headerlink" title="4. 求散布矩阵的特征值和特征向量"></a>4. 求散布矩阵的特征值和特征向量</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[eigen_vectors, dianogol_matrix] = eig(scatter_matrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 从对角矩阵获取特征值</span></span><br><span class="line">eigen_values = <span class="built_in">diag</span>(dianogol_matrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 对特征值进行排序，获得排列后的特征值和索引</span></span><br><span class="line">[sorted_eigen_values, index] = <span class="built_in">sort</span>(eigen_values, <span class="string">'descend'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">% 获取排序后的征值对应的特征向量</span></span><br><span class="line">sorted_eigen_vectors = eigen_vectors(:, index);</span><br></pre></td></tr></table></figure>

<p>这里得到的特征向量直接就构成了 46x46 （即图片原始尺寸）的矩阵，取出其中的一些列，可以构成投影矩阵。与 PCA 不同的是，这里的矩阵并不是一张脸的模样。</p>
<h3 id="5-取一个人的脸，进行重建"><a href="#5-取一个人的脸，进行重建" class="headerlink" title="5. 取一个人的脸，进行重建"></a>5. 取一个人的脸，进行重建</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">10</span>:<span class="number">5</span>:<span class="number">46</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 取得投影矩阵</span></span><br><span class="line">    project_matrix = sorted_eigen_vectors(:,<span class="number">1</span>:<span class="built_in">i</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 重建人脸并显示</span></span><br><span class="line">    rebuild_faces = project_matrix * (project_matrix' * single_face) + mean_face;</span><br><span class="line">    subplot(<span class="number">2</span>, <span class="number">4</span>, index);</span><br><span class="line">    index = index + <span class="number">1</span>;</span><br><span class="line">    fig = show_face(rebuild_faces);</span><br><span class="line">    title(sprintf(<span class="string">"i=%d"</span>, <span class="built_in">i</span>));    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">i</span> == <span class="number">45</span>)</span><br><span class="line">        waitfor(fig);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>效果如下图所示，与PCA相比，2DPCA只要较少的特征向量就可以很好地重塑人脸。</p>
<p><img src="https://pic1.zhimg.com/80/v2-22b6d58019f32f412eb1d9ac1b32c6d8_720w.png" alt="2DPCA 人脸重构"></p>
<p>下图是使用 PCA 进行人脸重构，可以与上图对比，注意 i 值的大小比对，i 值是使用的特征向量数量。</p>
<p><img src="https://pic4.zhimg.com/80/v2-48ed671d57d950ebe9684bc36bbd4b9f_720w.png" alt="PCA 人脸重塑"></p>
<h3 id="6-进行人脸识别"><a href="#6-进行人脸识别" class="headerlink" title="6. 进行人脸识别"></a>6. 进行人脸识别</h3><p>将待测人脸通过前面求得的投影矩阵投影到子空间后，计算与已知人脸的距离，并使用最近邻分类器KNN进行分类，这部分和 PCA 一模一样。最终得到的识别率正确率在 93% 左右。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">index = <span class="number">1</span>;</span><br><span class="line">X = [];</span><br><span class="line">Y = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">10</span>:<span class="number">5</span>:<span class="number">46</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 取得投影矩阵</span></span><br><span class="line">    project_matrix = sorted_eigen_vectors(:,<span class="number">1</span>:<span class="built_in">i</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 测试、训练数据降维</span></span><br><span class="line">    projected_train_data = <span class="built_in">zeros</span>(<span class="built_in">i</span>,<span class="number">46</span>,<span class="built_in">size</span>(train_data, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">size</span>(train_data, <span class="number">3</span>)</span><br><span class="line">        projected_train_data(:,:,<span class="built_in">j</span>) = project_matrix' * (train_data(:,:,<span class="built_in">j</span>) - mean_face);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    projected_test_data = <span class="built_in">zeros</span>(<span class="built_in">i</span>,<span class="number">46</span>,<span class="built_in">size</span>(test_data, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">size</span>(test_data, <span class="number">3</span>)</span><br><span class="line">        projected_test_data(:,:,<span class="built_in">j</span>) = project_matrix' * (test_data(:,:,<span class="built_in">j</span>) - mean_face);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 开始测试识别率</span></span><br><span class="line">    <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% KNN的k值</span></span><br><span class="line">	k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 用于保存最小的k个值的矩阵</span></span><br><span class="line">    <span class="comment">% 用于保存最小k个值对应的人标签的矩阵</span></span><br><span class="line">    minimun_k_values = <span class="built_in">zeros</span>(k,<span class="number">1</span>);</span><br><span class="line">    label_of_minimun_k_values = <span class="built_in">zeros</span>(k,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 测试脸的数量</span></span><br><span class="line">    test_face_number = <span class="built_in">size</span>(projected_test_data, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 识别正确数量</span></span><br><span class="line">    correct_predict_number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 遍历每一个待测试人脸</span></span><br><span class="line">    <span class="keyword">for</span> each_test_face_index = <span class="number">1</span>:test_face_number</span><br><span class="line"></span><br><span class="line">        each_test_face = projected_test_data(:, :, each_test_face_index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">% 先把k个值填满，避免在迭代中反复判断</span></span><br><span class="line">        <span class="keyword">for</span> each_train_face_index = <span class="number">1</span>:k</span><br><span class="line">            minimun_k_values(each_train_face_index,<span class="number">1</span>) = norm(each_test_face - projected_train_data(:, :,each_train_face_index));</span><br><span class="line">            label_of_minimun_k_values(each_train_face_index,<span class="number">1</span>) = <span class="built_in">floor</span>((train_data_index(<span class="number">1</span>,each_train_face_index) - <span class="number">1</span>) / <span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% 找出k个值中最大值及其下标</span></span><br><span class="line">        [max_value, index_of_max_value] = <span class="built_in">max</span>(minimun_k_values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">% 计算与剩余每一个已知人脸的距离</span></span><br><span class="line">        <span class="keyword">for</span> each_train_face_index = k+<span class="number">1</span>:<span class="built_in">size</span>(projected_train_data, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">% 计算距离</span></span><br><span class="line">            distance = norm(each_test_face - projected_train_data(:, :,each_train_face_index));</span><br><span class="line"></span><br><span class="line">            <span class="comment">% 遇到更小的距离就更新距离和标签</span></span><br><span class="line">            <span class="keyword">if</span> (distance &lt; max_value)</span><br><span class="line">                minimun_k_values(index_of_max_value,<span class="number">1</span>) = distance;</span><br><span class="line">                label_of_minimun_k_values(index_of_max_value,<span class="number">1</span>) = <span class="built_in">floor</span>((train_data_index(<span class="number">1</span>,each_train_face_index) - <span class="number">1</span>) / <span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">                [max_value, index_of_max_value] = <span class="built_in">max</span>(minimun_k_values);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% 最终得到距离最小的k个值以及对应的标签</span></span><br><span class="line">        <span class="comment">% 取出出现次数最多的值，为预测的人脸标签</span></span><br><span class="line">        predict_label = mode(label_of_minimun_k_values);</span><br><span class="line">        real_label = <span class="built_in">floor</span>((test_data_index(<span class="number">1</span>,each_test_face_index) - <span class="number">1</span>) / <span class="number">10</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (predict_label == real_label)</span><br><span class="line">            <span class="comment">%fprintf("预测值：%d，实际值:%d，正确\n",predict_label,real_label);</span></span><br><span class="line">            correct_predict_number = correct_predict_number + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">%fprintf("预测值：%d，实际值:%d，错误\n",predict_label,real_label);</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    correct_rate = correct_predict_number/test_face_number;</span><br><span class="line">    </span><br><span class="line">    X = [X <span class="built_in">i</span>];</span><br><span class="line">    Y = [Y correct_rate];</span><br><span class="line">    </span><br><span class="line">    fprintf(<span class="string">"i=%d，总测试样本：%d，正确数:%d，正确率：%1f\n"</span>, <span class="built_in">i</span>,test_face_number,correct_predict_number,correct_rate);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(X,Y);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br></pre></td></tr></table></figure>

<h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 400张图，一共40人，一人10张</span></span><br><span class="line">load(<span class="string">'ORL4646.mat'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 训练数据与测试数据的生成</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 取出前40%作为测试数据，剩下60%作为训练数据</span></span><br><span class="line">test_data_index = [];</span><br><span class="line">train_data_index = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">0</span>:<span class="number">39</span></span><br><span class="line">    test_data_index = [test_data_index <span class="number">10</span>*<span class="built_in">i</span>+<span class="number">1</span>:<span class="number">10</span>*<span class="built_in">i</span>+<span class="number">4</span>];</span><br><span class="line">    train_data_index = [train_data_index <span class="number">10</span>*<span class="built_in">i</span>+<span class="number">5</span>:<span class="number">10</span>*(<span class="built_in">i</span>+<span class="number">1</span>)];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">test_data = ORL4646(:, :, test_data_index);</span><br><span class="line">train_data = ORL4646(:, :,train_data_index);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 取得中心化数据</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 求平均脸，即每一层分别求均值</span></span><br><span class="line">mean_face = <span class="built_in">mean</span>(train_data, <span class="number">3</span>);</span><br><span class="line">waitfor(show_face(mean_face));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 求得协方差矩阵的特征值与特征向量</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 协方差矩阵</span></span><br><span class="line">cov_matrix = <span class="built_in">zeros</span>(<span class="number">46</span>, <span class="number">46</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">size</span>(train_data, <span class="number">3</span>)</span><br><span class="line">    centered_face = train_data(:,:,<span class="built_in">i</span>) - mean_face;</span><br><span class="line">    cov_matrix = cov_matrix + centered_face' * centered_face;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 散布矩阵</span></span><br><span class="line">scatter_matrix = cov_matrix / (<span class="built_in">size</span>(train_data, <span class="number">3</span>) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">[eigen_vectors, dianogol_matrix] = eig(scatter_matrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 从对角矩阵获取特征值</span></span><br><span class="line">eigen_values = <span class="built_in">diag</span>(dianogol_matrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 对特征值进行排序，获得排列后的特征值和索引</span></span><br><span class="line">[sorted_eigen_values, index] = <span class="built_in">sort</span>(eigen_values, <span class="string">'descend'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">% 获取排序后的征值对应的特征向量</span></span><br><span class="line">sorted_eigen_vectors = eigen_vectors(:, index);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 筛选出特征脸</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 取出第一个人的人脸，用于重建</span></span><br><span class="line">single_face = train_data(:, :, <span class="number">1</span>) - mean_face;</span><br><span class="line"></span><br><span class="line">index = <span class="number">1</span>;</span><br><span class="line">X = [];</span><br><span class="line">Y = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">10</span>:<span class="number">5</span>:<span class="number">46</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 取得投影矩阵</span></span><br><span class="line">    project_matrix = sorted_eigen_vectors(:,<span class="number">1</span>:<span class="built_in">i</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 重建人脸并显示</span></span><br><span class="line">    rebuild_faces = project_matrix * (project_matrix' * single_face) + mean_face;</span><br><span class="line">    subplot(<span class="number">2</span>, <span class="number">4</span>, index);</span><br><span class="line">    index = index + <span class="number">1</span>;</span><br><span class="line">    fig = show_face(rebuild_faces);</span><br><span class="line">    title(sprintf(<span class="string">"i=%d"</span>, <span class="built_in">i</span>));    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">i</span> == <span class="number">45</span>)</span><br><span class="line">        waitfor(fig);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 测试、训练数据降维</span></span><br><span class="line">    projected_train_data = <span class="built_in">zeros</span>(<span class="built_in">i</span>,<span class="number">46</span>,<span class="built_in">size</span>(train_data, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">size</span>(train_data, <span class="number">3</span>)</span><br><span class="line">        projected_train_data(:,:,<span class="built_in">j</span>) = project_matrix' * (train_data(:,:,<span class="built_in">j</span>) - mean_face);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    projected_test_data = <span class="built_in">zeros</span>(<span class="built_in">i</span>,<span class="number">46</span>,<span class="built_in">size</span>(test_data, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">size</span>(test_data, <span class="number">3</span>)</span><br><span class="line">        projected_test_data(:,:,<span class="built_in">j</span>) = project_matrix' * (test_data(:,:,<span class="built_in">j</span>) - mean_face);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 开始测试识别率</span></span><br><span class="line">    <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% KNN的k值</span></span><br><span class="line">	k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 用于保存最小的k个值的矩阵</span></span><br><span class="line">    <span class="comment">% 用于保存最小k个值对应的人标签的矩阵</span></span><br><span class="line">    minimun_k_values = <span class="built_in">zeros</span>(k,<span class="number">1</span>);</span><br><span class="line">    label_of_minimun_k_values = <span class="built_in">zeros</span>(k,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 测试脸的数量</span></span><br><span class="line">    test_face_number = <span class="built_in">size</span>(projected_test_data, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 识别正确数量</span></span><br><span class="line">    correct_predict_number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 遍历每一个待测试人脸</span></span><br><span class="line">    <span class="keyword">for</span> each_test_face_index = <span class="number">1</span>:test_face_number</span><br><span class="line"></span><br><span class="line">        each_test_face = projected_test_data(:, :, each_test_face_index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">% 先把k个值填满，避免在迭代中反复判断</span></span><br><span class="line">        <span class="keyword">for</span> each_train_face_index = <span class="number">1</span>:k</span><br><span class="line">            minimun_k_values(each_train_face_index,<span class="number">1</span>) = norm(each_test_face - projected_train_data(:, :,each_train_face_index));</span><br><span class="line">            label_of_minimun_k_values(each_train_face_index,<span class="number">1</span>) = <span class="built_in">floor</span>((train_data_index(<span class="number">1</span>,each_train_face_index) - <span class="number">1</span>) / <span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% 找出k个值中最大值及其下标</span></span><br><span class="line">        [max_value, index_of_max_value] = <span class="built_in">max</span>(minimun_k_values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">% 计算与剩余每一个已知人脸的距离</span></span><br><span class="line">        <span class="keyword">for</span> each_train_face_index = k+<span class="number">1</span>:<span class="built_in">size</span>(projected_train_data, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">% 计算距离</span></span><br><span class="line">            distance = norm(each_test_face - projected_train_data(:, :,each_train_face_index));</span><br><span class="line"></span><br><span class="line">            <span class="comment">% 遇到更小的距离就更新距离和标签</span></span><br><span class="line">            <span class="keyword">if</span> (distance &lt; max_value)</span><br><span class="line">                minimun_k_values(index_of_max_value,<span class="number">1</span>) = distance;</span><br><span class="line">                label_of_minimun_k_values(index_of_max_value,<span class="number">1</span>) = <span class="built_in">floor</span>((train_data_index(<span class="number">1</span>,each_train_face_index) - <span class="number">1</span>) / <span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">                [max_value, index_of_max_value] = <span class="built_in">max</span>(minimun_k_values);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% 最终得到距离最小的k个值以及对应的标签</span></span><br><span class="line">        <span class="comment">% 取出出现次数最多的值，为预测的人脸标签</span></span><br><span class="line">        predict_label = mode(label_of_minimun_k_values);</span><br><span class="line">        real_label = <span class="built_in">floor</span>((test_data_index(<span class="number">1</span>,each_test_face_index) - <span class="number">1</span>) / <span class="number">10</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (predict_label == real_label)</span><br><span class="line">            <span class="comment">%fprintf("预测值：%d，实际值:%d，正确\n",predict_label,real_label);</span></span><br><span class="line">            correct_predict_number = correct_predict_number + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">%fprintf("预测值：%d，实际值:%d，错误\n",predict_label,real_label);</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    correct_rate = correct_predict_number/test_face_number;</span><br><span class="line">    </span><br><span class="line">    X = [X <span class="built_in">i</span>];</span><br><span class="line">    Y = [Y correct_rate];</span><br><span class="line">    </span><br><span class="line">    fprintf(<span class="string">"i=%d，总测试样本：%d，正确数:%d，正确率：%1f\n"</span>, <span class="built_in">i</span>,test_face_number,correct_predict_number,correct_rate);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(X,Y);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 输入向量，显示脸</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fig</span> = <span class="title">show_face</span><span class="params">(vector)</span></span></span><br><span class="line">    fig = imshow(mat2gray(<span class="built_in">reshape</span>(vector, [<span class="number">46</span>, <span class="number">46</span>])));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 显示矩阵中某些脸</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fig</span> = <span class="title">show_faces</span><span class="params">(faces)</span></span></span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line">    index_of_image_to_show = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span>,<span class="number">30</span>,<span class="number">35</span>,<span class="number">40</span>,<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=index_of_image_to_show</span><br><span class="line">        subplot(<span class="number">2</span>,<span class="number">5</span>,count);</span><br><span class="line">        fig = show_face(faces(:, :, <span class="built_in">i</span>));</span><br><span class="line">        title(sprintf(<span class="string">"i=%d"</span>, <span class="built_in">i</span>));</span><br><span class="line">        count = count + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://ieeexplore.ieee.org/abstract/document/1261097" target="_blank" rel="noopener">Two-dimensional PCA: a new approach to appearance-based face representation and recognition | IEEE Journals &amp; Magazine | IEEE Xplore</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/138101583" target="_blank" rel="noopener">对于2D PCA的理解与复现 - 知乎 (zhihu.com)</a></p>
<p>本文地址： <a href="https://www.chimaoshu.top/基于-2DPCA-的人脸识别方法——特征脸法-3/">https://www.chimaoshu.top/基于-2DPCA-的人脸识别方法——特征脸法-3/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>PCA</tag>
        <tag>人脸识别</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 PCA 的人脸识别方法--特征脸法[2]</title>
    <url>/%E5%9F%BA%E4%BA%8E-PCA-%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%96%B9%E6%B3%95-%E7%89%B9%E5%BE%81%E8%84%B8%E6%B3%95-2/</url>
    <content><![CDATA[<h1 id="基于-PCA-的人脸识别方法——特征脸法-2"><a href="#基于-PCA-的人脸识别方法——特征脸法-2" class="headerlink" title="基于 PCA 的人脸识别方法——特征脸法[2]"></a>基于 PCA 的人脸识别方法——特征脸法[2]</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次主要说说 Matlab 实现与可视化。上次用了 YaleB 数据集不够好用，每个人的人脸图片数量不同，导致训练数据和测试数据划分比较麻烦。这次换了ORL数据集，好了些。</p>
<h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><ol>
<li>数据读取与预处理，ORL数据集一共400张图，40人，一个人10张。每个人10张照片，取4张作为测试数据，6张作为训练数据。</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 400张图，一共40人，一人10张</span></span><br><span class="line">load(<span class="string">'ORL4646.mat'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 重塑后400列，一列是一张脸</span></span><br><span class="line">reshaped_faces = <span class="built_in">reshape</span>(ORL4646, <span class="number">46</span>*<span class="number">46</span>,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 取出前40%作为测试数据，剩下60%作为训练数据</span></span><br><span class="line">test_data_index = [];</span><br><span class="line">train_data_index = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">0</span>:<span class="number">39</span></span><br><span class="line">    test_data_index = [test_data_index <span class="number">10</span>*<span class="built_in">i</span>+<span class="number">1</span>:<span class="number">10</span>*<span class="built_in">i</span>+<span class="number">4</span>];</span><br><span class="line">    train_data_index = [train_data_index <span class="number">10</span>*<span class="built_in">i</span>+<span class="number">5</span>:<span class="number">10</span>*(<span class="built_in">i</span>+<span class="number">1</span>)];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">test_data = reshaped_faces(:, test_data_index);</span><br><span class="line">train_data = reshaped_faces(:, train_data_index);</span><br></pre></td></tr></table></figure>

<p>得到的训练数据和测试数据都是一个矩阵，每一列就是一张脸。通过提取训练数据中的部分列向量，重塑为方阵，并转化为灰度图像得到下图，代表了未经处理的原始数据，如图所示：</p>
<img src="https://pic1.zhimg.com/80/v2-af75551ea61d0afe250e2c36423009c7_720w.png" alt="原始数据" style="zoom:50%;" />

<a id="more"></a>

<ol start="2">
<li><p>对训练数据的所有列向量求平均，得到平均列向量，将其重塑为图像即为”平均脸“，如图所示。由于该图像源于所有人脸的平均，所以直观上看可以看出人脸的轮廓，但五官细节较为模糊。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 求平均脸，即每一列分别求均值</span></span><br><span class="line">mean_face = <span class="built_in">mean</span>(train_data, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>



</li>
</ol>
   <img src="https://pic1.zhimg.com/80/v2-c551f75d984fc0d79fc5f0c5d98c1fd8_720w.png" alt="平均脸" style="zoom:50%;" />

<ol start="3">
<li><p>将所有列向量减去平均列向量，得到中心化后的数据。将部分中心化后的列向量重塑后转化为灰度图像，即为中心化后的脸。由于减去了平均人脸，因此相比原始人脸，中心化后的人脸的灰度值更低，图像直观上显得更加暗淡。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">centered_face = (train_data - mean_face);</span><br></pre></td></tr></table></figure>

<img src="https://pic2.zhimg.com/80/v2-a7e6d21d2be0d333d35b1e25631c47c2_720w.png" alt="中心化数据" style="zoom:50%;" />
</li>
<li><p>求出协方差矩阵的特征值与特征向量，将特征向量按照特征值大小排序。下图是部分特征向量通过重塑后转化为灰度图像得到的特征脸。从直观上可以看出随着特征值的降低，对应的特征脸越来越模糊，这是因为特征值大的特征脸保留了更多的有效信息。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 协方差矩阵</span></span><br><span class="line">cov_matrix = centered_face * centered_face';</span><br><span class="line">[eigen_vectors, dianogol_matrix] = eig(cov_matrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 从对角矩阵获取特征值</span></span><br><span class="line">eigen_values = <span class="built_in">diag</span>(dianogol_matrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 对特征值进行排序，获得排列后的特征值和索引</span></span><br><span class="line">[sorted_eigen_values, index] = <span class="built_in">sort</span>(eigen_values, <span class="string">'descend'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">% 获取排序后的征值对应的特征向量</span></span><br><span class="line">sorted_eigen_vectors = eigen_vectors(:, index);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 特征脸(所有）</span></span><br><span class="line">all_eigen_faces = sorted_eigen_vectors;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   <img src="https://pic4.zhimg.com/80/v2-f900daeddee23b2b36e859957f9e6cee_720w.png" alt="特征脸"></p>
<p>   值得一提的是，这里也可以使用SVD的方式去求特征脸，详见上文。</p>
<ol start="5">
<li>取出第一张人脸，使用不同数量的特征向量进行重构。</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 取出第一个人的人脸，用于重建</span></span><br><span class="line">single_face = centered_face(:,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">20</span>:<span class="number">20</span>:<span class="number">160</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 取出相应数量特征脸</span></span><br><span class="line">    eigen_faces = all_eigen_faces(:,<span class="number">1</span>:<span class="built_in">i</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 重建人脸并显示</span></span><br><span class="line">    rebuild_faces = eigen_faces * (eigen_faces' * single_face) + mean_face;</span><br><span class="line">    subplot(<span class="number">2</span>, <span class="number">4</span>, index);</span><br><span class="line">    index = index + <span class="number">1</span>;</span><br><span class="line">    fig = show_face(rebuild_faces);</span><br><span class="line">    title(sprintf(<span class="string">"i=%d"</span>, <span class="built_in">i</span>));    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">i</span> == <span class="number">160</span>)</span><br><span class="line">    	waitfor(fig);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>下图是分别在20，40，60，…，160数量的特征向量下重构的人脸。从直观上可以看出随着特征向量数量的增加，重构出的人脸越来越清晰。这是因为使用越多的特征向量进行人脸重构，丢失的信息越少，因此重构出的人脸更加清晰。</p>
<p><img src="https://pic1.zhimg.com/80/v2-48ed671d57d950ebe9684bc36bbd4b9f_720w.png" alt="使用不同的人脸进行重构"></p>
<ol start="6">
<li><p>计算不同数量特征向量下，人脸的识别准确度，思路是：将人脸投影到低维空间中，计算未知人脸与所有已知人脸的距离（欧几里得距离），然后使用最近邻分类器KNN进行识别。最终的准确率在 93%-97% 之间。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">index = <span class="number">1</span>;</span><br><span class="line">X = [];</span><br><span class="line">Y = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">10</span>:<span class="number">10</span>:<span class="number">160</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 取出相应数量特征脸</span></span><br><span class="line">    eigen_faces = all_eigen_faces(:,<span class="number">1</span>:<span class="built_in">i</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 测试、训练数据降维</span></span><br><span class="line">    projected_train_data = eigen_faces' * (train_data - mean_face);</span><br><span class="line">    projected_test_data = eigen_faces' * (test_data - mean_face);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 开始测试识别率</span></span><br><span class="line">    <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% KNN的k值</span></span><br><span class="line">	<span class="keyword">for</span> k=<span class="number">1</span>:<span class="number">6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% 用于保存最小的k个值的矩阵</span></span><br><span class="line">        <span class="comment">% 用于保存最小k个值对应的人标签的矩阵</span></span><br><span class="line">        minimun_k_values = <span class="built_in">zeros</span>(k,<span class="number">1</span>);</span><br><span class="line">        label_of_minimun_k_values = <span class="built_in">zeros</span>(k,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">% 测试脸的数量</span></span><br><span class="line">        test_face_number = <span class="built_in">size</span>(projected_test_data, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">% 识别正确数量</span></span><br><span class="line">        correct_predict_number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">% 遍历每一个待测试人脸</span></span><br><span class="line">        <span class="keyword">for</span> each_test_face_index = <span class="number">1</span>:test_face_number</span><br><span class="line"></span><br><span class="line">            each_test_face = projected_test_data(:,each_test_face_index);</span><br><span class="line"></span><br><span class="line">            <span class="comment">% 先把k个值填满，避免在迭代中反复判断</span></span><br><span class="line">            <span class="keyword">for</span> each_train_face_index = <span class="number">1</span>:k</span><br><span class="line">                minimun_k_values(each_train_face_index,<span class="number">1</span>) = norm(each_test_face - projected_train_data(:,each_train_face_index));</span><br><span class="line">                label_of_minimun_k_values(each_train_face_index,<span class="number">1</span>) = <span class="built_in">floor</span>((train_data_index(<span class="number">1</span>,each_train_face_index) - <span class="number">1</span>) / <span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">% 找出k个值中最大值及其下标</span></span><br><span class="line">            [max_value, index_of_max_value] = <span class="built_in">max</span>(minimun_k_values);</span><br><span class="line"></span><br><span class="line">            <span class="comment">% 计算与剩余每一个已知人脸的距离</span></span><br><span class="line">            <span class="keyword">for</span> each_train_face_index = k+<span class="number">1</span>:<span class="built_in">size</span>(projected_train_data,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">% 计算距离</span></span><br><span class="line">                distance = norm(each_test_face - projected_train_data(:,each_train_face_index));</span><br><span class="line"></span><br><span class="line">                <span class="comment">% 遇到更小的距离就更新距离和标签</span></span><br><span class="line">                <span class="keyword">if</span> (distance &lt; max_value)</span><br><span class="line">                    minimun_k_values(index_of_max_value,<span class="number">1</span>) = distance;</span><br><span class="line">                    label_of_minimun_k_values(index_of_max_value,<span class="number">1</span>) = <span class="built_in">floor</span>((train_data_index(<span class="number">1</span>,each_train_face_index) - <span class="number">1</span>) / <span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">                    [max_value, index_of_max_value] = <span class="built_in">max</span>(minimun_k_values);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">% 最终得到距离最小的k个值以及对应的标签</span></span><br><span class="line">            <span class="comment">% 取出出现次数最多的值，为预测的人脸标签</span></span><br><span class="line">            predict_label = mode(label_of_minimun_k_values);</span><br><span class="line">            real_label = <span class="built_in">floor</span>((test_data_index(<span class="number">1</span>,each_test_face_index) - <span class="number">1</span>) / <span class="number">10</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (predict_label == real_label)</span><br><span class="line">                <span class="comment">%fprintf("预测值：%d，实际值:%d，正确\n",predict_label,real_label);</span></span><br><span class="line">                correct_predict_number = correct_predict_number + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">%fprintf("预测值：%d，实际值:%d，错误\n",predict_label,real_label);</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        correct_rate = correct_predict_number/test_face_number;</span><br><span class="line"></span><br><span class="line">        X = [X k];</span><br><span class="line">        Y = [Y correct_rate];</span><br><span class="line">        </span><br><span class="line">        fprintf(<span class="string">"k=%d，i=%d，总测试样本：%d，正确数:%d，正确率：%1f\n"</span>, k, <span class="built_in">i</span>,test_face_number,correct_predict_number,correct_rate);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">waitfor(<span class="built_in">plot</span>(X,Y));</span><br></pre></td></tr></table></figure>
</li>
<li><p>人脸投影到低维空间的可视化：分别将人脸投影到二维空间与三维空间，并画图。</p>
</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 二三维可视化</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 取出相应数量特征脸</span></span><br><span class="line">    eigen_faces = all_eigen_faces(:,<span class="number">1</span>:<span class="built_in">i</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 投影</span></span><br><span class="line">    projected_test_data = eigen_faces' * (test_data - mean_face);</span><br><span class="line">    </span><br><span class="line">    color = [];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="number">160</span></span><br><span class="line">        color = [color <span class="built_in">floor</span>((<span class="built_in">j</span><span class="number">-1</span>)/<span class="number">4</span>)*<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 显示</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">i</span> == <span class="number">2</span>)</span><br><span class="line">        waitfor(<span class="built_in">scatter</span>(projected_test_data(<span class="number">1</span>, :), projected_test_data(<span class="number">2</span>, :), [], color));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        waitfor(<span class="built_in">scatter3</span>(projected_test_data(<span class="number">1</span>, :), projected_test_data(<span class="number">2</span>, :), projected_test_data(<span class="number">3</span>, :), [], color));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<img src="https://pic4.zhimg.com/80/v2-42364c1fbd82c5bd49b3c2ebb35eb68d_720w.png" alt="二维投影" style="zoom:67%;" />

<p>上图将人脸投影到二维空间下的可视化表示，每一个点代表一张人脸的图像，颜色相同的点代表同一个人的脸。</p>
<p>下面两图分别是在不同的两个角度下观察人脸数据在三维空间下的投影。其中每个点代表一张人脸图片，颜色相同的点代表同一人脸。由于同一人的人脸相近，因此颜色相同的点总是聚集地更加紧凑一些。</p>
<img src="https://pic1.zhimg.com/80/v2-b93a5323ebabf99fee4da23e34437af3_720w.png" alt="三维投影--角度一" style="zoom:67%;" />

<img src="https://pic2.zhimg.com/80/v2-b28e7539b316ae71d17c8eb6aa85ecbc_720w.png" alt="三维空间--角度2" style="zoom:67%;" />

<h2 id="所有代码"><a href="#所有代码" class="headerlink" title="所有代码"></a>所有代码</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 400张图，一共40人，一人10张</span></span><br><span class="line">load(<span class="string">'ORL4646.mat'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 训练数据与测试数据的生成</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 重塑后400列，一列是一张脸</span></span><br><span class="line">reshaped_faces = <span class="built_in">reshape</span>(ORL4646, <span class="number">46</span>*<span class="number">46</span>,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 取出前40%作为测试数据，剩下60%作为训练数据</span></span><br><span class="line">test_data_index = [];</span><br><span class="line">train_data_index = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">0</span>:<span class="number">39</span></span><br><span class="line">    test_data_index = [test_data_index <span class="number">10</span>*<span class="built_in">i</span>+<span class="number">1</span>:<span class="number">10</span>*<span class="built_in">i</span>+<span class="number">4</span>];</span><br><span class="line">    train_data_index = [train_data_index <span class="number">10</span>*<span class="built_in">i</span>+<span class="number">5</span>:<span class="number">10</span>*(<span class="built_in">i</span>+<span class="number">1</span>)];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">test_data = reshaped_faces(:, test_data_index);</span><br><span class="line">train_data = reshaped_faces(:,train_data_index);</span><br><span class="line"></span><br><span class="line">waitfor(show_faces(train_data));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 取得中心化数据</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 求平均脸，即每一列分别求均值</span></span><br><span class="line">mean_face = <span class="built_in">mean</span>(train_data, <span class="number">2</span>);</span><br><span class="line">waitfor(show_face(mean_face));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 中心化每一列是一个一张图</span></span><br><span class="line">centered_face = (train_data - mean_face);</span><br><span class="line">waitfor(show_faces(centered_face));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 求得协方差矩阵的特征值与特征向量</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% % 求内积矩阵，是协方差矩阵的替代</span></span><br><span class="line"><span class="comment">% % 内积矩阵的特征向量与对角矩阵</span></span><br><span class="line"><span class="comment">% inner_product_matrix = centered_face' * centered_face;</span></span><br><span class="line"><span class="comment">% [eigen_vectors, dianogol_matrix] = eig(inner_product_matrix);</span></span><br><span class="line"><span class="comment">% eigen_vectors = centered_face * eigen_vectors;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 协方差矩阵</span></span><br><span class="line">cov_matrix = centered_face * centered_face';</span><br><span class="line">[eigen_vectors, dianogol_matrix] = eig(cov_matrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 从对角矩阵获取特征值</span></span><br><span class="line">eigen_values = <span class="built_in">diag</span>(dianogol_matrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 对特征值进行排序，获得排列后的特征值和索引</span></span><br><span class="line">[sorted_eigen_values, index] = <span class="built_in">sort</span>(eigen_values, <span class="string">'descend'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">% 获取排序后的征值对应的特征向量</span></span><br><span class="line">sorted_eigen_vectors = eigen_vectors(:, index);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 筛选出特征脸</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 特征脸(所有）</span></span><br><span class="line">all_eigen_faces = sorted_eigen_vectors;</span><br><span class="line">waitfor(show_faces(all_eigen_faces));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 取出第一个人的人脸，用于重建</span></span><br><span class="line">single_face = centered_face(:,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">index = <span class="number">1</span>;</span><br><span class="line">X = [];</span><br><span class="line">Y = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">10</span>:<span class="number">10</span>:<span class="number">160</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 取出相应数量特征脸</span></span><br><span class="line">    eigen_faces = all_eigen_faces(:,<span class="number">1</span>:<span class="built_in">i</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 重建人脸并显示</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mod</span>(<span class="built_in">i</span>,<span class="number">20</span>)==<span class="number">0</span>)</span><br><span class="line">        rebuild_faces = eigen_faces * (eigen_faces' * single_face) + mean_face;</span><br><span class="line">        subplot(<span class="number">2</span>, <span class="number">4</span>, index);</span><br><span class="line">        index = index + <span class="number">1</span>;</span><br><span class="line">        fig = show_face(rebuild_faces);</span><br><span class="line">        title(sprintf(<span class="string">"i=%d"</span>, <span class="built_in">i</span>));    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">i</span> == <span class="number">160</span>)</span><br><span class="line">            waitfor(fig);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 测试、训练数据降维</span></span><br><span class="line">    projected_train_data = eigen_faces' * (train_data - mean_face);</span><br><span class="line">    projected_test_data = eigen_faces' * (test_data - mean_face);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 开始测试识别率</span></span><br><span class="line">    <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% KNN的k值</span></span><br><span class="line">	<span class="keyword">for</span> k=<span class="number">1</span>:<span class="number">6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% 用于保存最小的k个值的矩阵</span></span><br><span class="line">        <span class="comment">% 用于保存最小k个值对应的人标签的矩阵</span></span><br><span class="line">        minimun_k_values = <span class="built_in">zeros</span>(k,<span class="number">1</span>);</span><br><span class="line">        label_of_minimun_k_values = <span class="built_in">zeros</span>(k,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">% 测试脸的数量</span></span><br><span class="line">        test_face_number = <span class="built_in">size</span>(projected_test_data, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">% 识别正确数量</span></span><br><span class="line">        correct_predict_number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">% 遍历每一个待测试人脸</span></span><br><span class="line">        <span class="keyword">for</span> each_test_face_index = <span class="number">1</span>:test_face_number</span><br><span class="line"></span><br><span class="line">            each_test_face = projected_test_data(:,each_test_face_index);</span><br><span class="line"></span><br><span class="line">            <span class="comment">% 先把k个值填满，避免在迭代中反复判断</span></span><br><span class="line">            <span class="keyword">for</span> each_train_face_index = <span class="number">1</span>:k</span><br><span class="line">                minimun_k_values(each_train_face_index,<span class="number">1</span>) = norm(each_test_face - projected_train_data(:,each_train_face_index));</span><br><span class="line">                label_of_minimun_k_values(each_train_face_index,<span class="number">1</span>) = <span class="built_in">floor</span>((train_data_index(<span class="number">1</span>,each_train_face_index) - <span class="number">1</span>) / <span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">% 找出k个值中最大值及其下标</span></span><br><span class="line">            [max_value, index_of_max_value] = <span class="built_in">max</span>(minimun_k_values);</span><br><span class="line"></span><br><span class="line">            <span class="comment">% 计算与剩余每一个已知人脸的距离</span></span><br><span class="line">            <span class="keyword">for</span> each_train_face_index = k+<span class="number">1</span>:<span class="built_in">size</span>(projected_train_data,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">% 计算距离</span></span><br><span class="line">                distance = norm(each_test_face - projected_train_data(:,each_train_face_index));</span><br><span class="line"></span><br><span class="line">                <span class="comment">% 遇到更小的距离就更新距离和标签</span></span><br><span class="line">                <span class="keyword">if</span> (distance &lt; max_value)</span><br><span class="line">                    minimun_k_values(index_of_max_value,<span class="number">1</span>) = distance;</span><br><span class="line">                    label_of_minimun_k_values(index_of_max_value,<span class="number">1</span>) = <span class="built_in">floor</span>((train_data_index(<span class="number">1</span>,each_train_face_index) - <span class="number">1</span>) / <span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">                    [max_value, index_of_max_value] = <span class="built_in">max</span>(minimun_k_values);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">% 最终得到距离最小的k个值以及对应的标签</span></span><br><span class="line">            <span class="comment">% 取出出现次数最多的值，为预测的人脸标签</span></span><br><span class="line">            predict_label = mode(label_of_minimun_k_values);</span><br><span class="line">            real_label = <span class="built_in">floor</span>((test_data_index(<span class="number">1</span>,each_test_face_index) - <span class="number">1</span>) / <span class="number">10</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (predict_label == real_label)</span><br><span class="line">                <span class="comment">%fprintf("预测值：%d，实际值:%d，正确\n",predict_label,real_label);</span></span><br><span class="line">                correct_predict_number = correct_predict_number + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">%fprintf("预测值：%d，实际值:%d，错误\n",predict_label,real_label);</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        correct_rate = correct_predict_number/test_face_number;</span><br><span class="line"></span><br><span class="line">        X = [X k];</span><br><span class="line">        Y = [Y correct_rate];</span><br><span class="line">        </span><br><span class="line">        fprintf(<span class="string">"k=%d，i=%d，总测试样本：%d，正确数:%d，正确率：%1f\n"</span>, k, <span class="built_in">i</span>,test_face_number,correct_predict_number,correct_rate);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">waitfor(<span class="built_in">plot</span>(X,Y));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 二三维可视化</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 取出相应数量特征脸</span></span><br><span class="line">    eigen_faces = all_eigen_faces(:,<span class="number">1</span>:<span class="built_in">i</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 投影</span></span><br><span class="line">    projected_test_data = eigen_faces' * (test_data - mean_face);</span><br><span class="line">    </span><br><span class="line">    color = [];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="number">160</span></span><br><span class="line">        color = [color <span class="built_in">floor</span>((<span class="built_in">j</span><span class="number">-1</span>)/<span class="number">4</span>)*<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 显示</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">i</span> == <span class="number">2</span>)</span><br><span class="line">        waitfor(<span class="built_in">scatter</span>(projected_test_data(<span class="number">1</span>, :), projected_test_data(<span class="number">2</span>, :), [], color));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        waitfor(<span class="built_in">scatter3</span>(projected_test_data(<span class="number">1</span>, :), projected_test_data(<span class="number">2</span>, :), projected_test_data(<span class="number">3</span>, :), [], color));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"><span class="comment">% 输入向量，显示脸</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fig</span> = <span class="title">show_face</span><span class="params">(vector)</span></span></span><br><span class="line">    fig = imshow(mat2gray(<span class="built_in">reshape</span>(vector, [<span class="number">46</span>, <span class="number">46</span>])));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 显示矩阵中某些脸</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fig</span> = <span class="title">show_faces</span><span class="params">(eigen_vectors)</span></span></span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line">    index_of_image_to_show = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span>,<span class="number">30</span>,<span class="number">35</span>,<span class="number">40</span>,<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=index_of_image_to_show</span><br><span class="line">        subplot(<span class="number">2</span>,<span class="number">5</span>,count);</span><br><span class="line">        fig = show_face(eigen_vectors(:, <span class="built_in">i</span>));</span><br><span class="line">        title(sprintf(<span class="string">"i=%d"</span>, <span class="built_in">i</span>));</span><br><span class="line">        count = count + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>本文地址： <a href="https://www.chimaoshu.top/基于-PCA-的人脸识别方法-特征脸法-2/">https://www.chimaoshu.top/基于-PCA-的人脸识别方法-特征脸法-2/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>PCA</tag>
        <tag>人脸识别</tag>
      </tags>
  </entry>
  <entry>
    <title>基于PCA的人脸识别方法——特征脸法</title>
    <url>/%E5%9F%BA%E4%BA%8EPCA%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E7%89%B9%E5%BE%81%E8%84%B8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="基于-PCA-的人脸识别方法——特征脸法"><a href="#基于-PCA-的人脸识别方法——特征脸法" class="headerlink" title="基于 PCA 的人脸识别方法——特征脸法"></a>基于 PCA 的人脸识别方法——特征脸法</h1><ul>
<li><p>论文：<a href="https://www.mitpressjournals.org/doi/pdfplus/10.1162/jocn.1991.3.1.71" target="_blank" rel="noopener">Eigenfaces for Recognition (mitpressjournals.org)</a></p>
</li>
<li><p>1991 年的论文，提出了一种借助 PCA 方法进行有效人脸识别的方法——特征脸法。</p>
</li>
<li><p>思路：借助 PCA 分析主要成分，对人脸数据进行降维，再进行相关计算，以减少复杂度。</p>
</li>
</ul>
<h2 id="PCA-的几何解释"><a href="#PCA-的几何解释" class="headerlink" title="PCA 的几何解释"></a>PCA 的几何解释</h2><ol>
<li><p>找到一组新的坐标轴，或者说是一组新的基（basis），用于表示原来的数据，使得在表示数据时不同轴是<strong>不相关的</strong>（即协方差为0）。</p>
</li>
<li><p>取出其中含有信息较多（即方差较大）的坐标轴（基），构成（span）一个新的空间，舍弃其他维度的信息。</p>
</li>
<li><p>由于新空间的维度小于原来的空间，所以把数据投影到新的空间后，可以大大降低数据的复杂度（虽然会损失少量信息）。</p>
</li>
</ol>
<a id="more"></a>

<p><img src="https://pic4.zhimg.com/80/v2-cdc06841330ffef8f47cebcd56a8fba9_720w.png" alt="_"></p>
<h2 id="PCA-的大致思路"><a href="#PCA-的大致思路" class="headerlink" title="PCA 的大致思路"></a>PCA 的大致思路</h2><ol>
<li>样本中心化：算出数据在每一个维度上的平均值，让该维数值减去这个平均值，中心化不会改变求得的新空间，但会减少计算量。</li>
<li>对中心化后的数据，算出这些数据的协方差矩阵。协方差矩阵的含义：第 i 行 k 列的值，表示 i k 对应的两个方向（坐标轴）的协方差。</li>
</ol>
<ol start="3">
<li><p>对协方差矩阵进行对角化，即算出协方差矩阵的特征值与特征向量。</p>
<p>含义：对角化意味着非对角线元素为0，也就意味着不同坐标轴（不同方向）之间两两互不相关（协方差为0）。而协方差矩阵对角线上元素，就是数据在各个方向上的方差（也是特征值），方差越大意味着数据在这个方向上的散度越大，也就意味着这个方向包含的信息更多。</p>
</li>
<li><p>取特征值大的一些特征向量构成一个矩阵 P，这个矩阵是一个投影矩阵：能够把原始空间的数据投影到新的空间。</p>
</li>
</ol>
<h2 id="特征脸法的大致思路"><a href="#特征脸法的大致思路" class="headerlink" title="特征脸法的大致思路"></a>特征脸法的大致思路</h2><ol>
<li><p>数据预处理：将每一张人脸拉成一个列向量，所有人脸构成一个矩阵，每列是一张列。</p>
</li>
<li><p>求平均脸：对每一行都求平均值，得到一个列向量，我们称之为“平均脸”，是所有人脸的平均。下图是 YaleB 数据集求得的一张平均脸。</p>
</li>
</ol>
<p><img src="https://pic1.zhimg.com/80/v2-918060b552a96c398d46f84574d5f2e4_720w.png" alt="平均脸"></p>
<ol start="3">
<li><p>样本中心化：每一个脸都减去平均脸。下图是原始数据在减去平均脸后得到的中心化的数据。</p>
<img src="https://pic1.zhimg.com/80/v2-65a459d10dbf796dcd4dbfec736c810a_720w.png" alt="中心化的数据" style="zoom:33%;" />


</li>
</ol>
<ol start="4">
<li><p>对中心化后的样本，求协方差矩阵的特征向量。每一个特征向量都是一张脸，我们称之为“特征脸”（eigenface），原始的人脸可以表示为特征脸的线性组合。</p>
<blockquote>
<p>比如，一张人脸图像可能是特征脸1的10%，加上特征脸2的55%，再减去特征脸3的3%。</p>
<p>——<a href="https://zh.wikipedia.org/zh-hans/特征脸" target="_blank" rel="noopener">特征脸 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
</blockquote>
</li>
</ol>
<p>   下图把特征脸按照特征值大小排列，可以看到特征值大的脸，其包含的有效信息更多。</p>
   <img src="https://pic2.zhimg.com/80/v2-62f392d4e1056457c15ccb4dd81dc539_720w.png" alt="特征脸" style="zoom:33%;" />



<ol start="5">
<li><p>取出特征值较大的特征脸，构成投影矩阵。这个投影矩阵可以把人脸投影到一个子空间上，我们称之为脸空间（face space）。</p>
</li>
<li><p>把某个人的所有脸都投影到脸空间中，求均值，得到脸空间中的一个点，称之为这个人的“特征”（pattern vector）。以此类推，求出每一个人的“特征”，每一个特征代表一个人的脸。</p>
</li>
<li><p>现在有了一个待识别的人脸，只要把它也投影成子空间的一个点，看这个点和空间中哪个点（这个点代表某个人的脸）离得近，我们就认为这个脸是某个人的。</p>
</li>
<li><p>如果它和“最近的脸”离得太远，我们认为这张图象并不是一张脸。</p>
</li>
</ol>
<h2 id="特征脸法的具体计算细节"><a href="#特征脸法的具体计算细节" class="headerlink" title="特征脸法的具体计算细节"></a>特征脸法的具体计算细节</h2><p>以 YaleB 数据集为例，进行分析。YaleB 数据集包含 2414 个人脸，每个人脸是 32x32=1024 大小。</p>
<ol>
<li><p>数据预处理：读取数据集，“YaleB_32x32.mat”包含已经处理好的数据，含有一个 2414x1024 大小的矩阵，每行是一张人脸。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">load(<span class="string">'YaleB_32x32.mat'</span>);</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>计算平均脸：对每一列都求出一个平均值，最终得到一个 1024 维的行向量，即平均脸。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mean_face = <span class="built_in">mean</span>(train_data, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>样本中心化：把原始数据每行是一个人脸，让每一行都减去平均脸，这里顺便做一次转置，与论文保持一致。转置后每一列是一张人脸。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">centered_face = (train_data - mean_face)';</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算写协方差矩阵的特征值、特征向量</p>
</li>
</ol>
<p>   一般来说，计算协方差矩阵特征值和特征向量的方法是，先计算协方差矩阵，然后求其特征值和特征向量。但是这种方法的计算规模较大，所以论文提出了一种更加节省算力的方法——SVD，<a href="https://zh.wikipedia.org/wiki/奇异值分解" target="_blank" rel="noopener">奇异值分解 - 维基百科，自由的百科全书 (wikipedia.org)</a>。</p>
<p>   论文给出了详细的推理过程，最终得出的结论是：计算 L = A’ * A ，而不是 Cov = A * A’ （Cov指的是协方差矩阵）。求出 L 的特征向量后，令其与前面求出的中心化数据 A 相乘后便可得到协方差矩阵的特征向量。</p>
   <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 这里L是协方差矩阵的替代</span></span><br><span class="line">L = centered_face' * centered_face;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 算特征向量与对角矩阵</span></span><br><span class="line">[eigen_vectors, dianogol_matrix] = eig(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 从对角矩阵获取特征值</span></span><br><span class="line">eigen_values = <span class="built_in">diag</span>(dianogol_matrix);</span><br></pre></td></tr></table></figure>


<ol start="5">
<li><p>取出特征值较大的特征向量，作为特征脸。特征值的累加如下图所示，排位靠前的几个特征值占了总特征值的大部分：</p>
<p><img src="https://pic4.zhimg.com/80/v2-b235c3e10511e5a15997553103317f6c_720w.jpeg" alt=""></p>
<p> 取出的特征向量构成投影矩阵，这个投影矩阵可以把人脸投影到一个子空间上，我们称之为脸空间（face space）。此后只要用投影矩阵去左乘数据，就能把数据投影到子空间中。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 对特征值进行排序，获得排列后的特征值和索引</span></span><br><span class="line">[sorted_eigen_values, index] = <span class="built_in">sort</span>(eigen_values, <span class="string">'descend'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">% 获取排序后的征值对应的特征向量</span></span><br><span class="line">sorted_eigen_vectors = eigen_vectors(:, index);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 特征脸(所有）</span></span><br><span class="line">eigen_faces = centered_face * sorted_eigen_vectors;</span><br><span class="line">waitfor(show_faces(eigen_faces));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 取出前90%的特征值对应的特征脸</span></span><br><span class="line">order = <span class="number">0</span>;</span><br><span class="line">sum_eigen_values = sum(sorted_eigen_values);</span><br><span class="line">target_eigen_values = sum_eigen_values * <span class="number">0.9</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=sorted_eigen_values'</span><br><span class="line">    count = count + <span class="built_in">i</span>;</span><br><span class="line">    order = order + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; target_eigen_values)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 占90%特征值对应的约简后的特征脸</span></span><br><span class="line">reduced_eigen_faces = eigen_faces(:,<span class="number">1</span>:order);</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="6">
<li><p>把某个人的所有脸都投影到脸空间上，求平均后得到一个”pattern vector”。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 将已知人脸投影到脸空间中，即eigenface pattern vector</span></span><br><span class="line"><span class="comment">% 每列是一个人脸的特征向量</span></span><br><span class="line">omega = reduced_eigen_faces' * centered_face;</span><br></pre></td></tr></table></figure>

<p>这里取出前五个人的人脸求平均值得到前五个人人的”pattern vector”，它代表了五个人的脸的特征：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 求5个人在脸空间中的pattern vector</span></span><br><span class="line">omega_k_1 = <span class="built_in">mean</span>(omega(:,<span class="number">1</span>:<span class="number">63</span>),<span class="number">2</span>);</span><br><span class="line">omega_k_2 = <span class="built_in">mean</span>(omega(:,<span class="number">64</span>:<span class="number">127</span>),<span class="number">2</span>);</span><br><span class="line">omega_k_3 = <span class="built_in">mean</span>(omega(:,<span class="number">128</span>:<span class="number">191</span>),<span class="number">2</span>);</span><br><span class="line">omega_k_4 = <span class="built_in">mean</span>(omega(:,<span class="number">192</span>:<span class="number">255</span>),<span class="number">2</span>);</span><br><span class="line">omega_k_5 = <span class="built_in">mean</span>(omega(:,<span class="number">256</span>:<span class="number">319</span>),<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>假设现在有了一个新的人脸，想要知道它是谁的人脸。那么首先需要将其投影到脸空间中：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 新人脸投影到脸空间中</span></span><br><span class="line">omega_new_face = reduced_eigen_faces' * (new_face - mean_face)';</span><br></pre></td></tr></table></figure>

<p>然后计算它和最近的点的距离，如果这个距离过大（阈值自主设定），那么我们可以认为它不是一张脸。</p>
<p>新的人脸投影到脸空间后，它实际上是脸空间中的一个点，其他已知人的“eigen pattern”也是一些脸空间的点。所以只要计算新的点与其他人的点的距离，如果这个点最接近 A 所属的点，那么我们就认为这个脸是属于 A 的。</p>
</li>
</ol>
   <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 计算新的点与特征向量均值的距离（论文中称之为与脸空间的距离）</span></span><br><span class="line">euclidean_matric_face_space = norm(omega_new_face - omega_k_face_space);</span><br></pre></td></tr></table></figure>

<pre><code>计算距离的过程，求的是欧几里得距离，论文中表示为二范数（欧几里得范数），实际上就是初高中解析几何中常见的”求空间中两        点距离的方法”。</code></pre>   <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 计算新的脸与五个人的脸的距离</span></span><br><span class="line">euclidean_matric_1 = norm(omega_new_face - omega_k_1);</span><br><span class="line">euclidean_matric_2 = norm(omega_new_face - omega_k_2);</span><br><span class="line">euclidean_matric_3 = norm(omega_new_face - omega_k_3);</span><br><span class="line">euclidean_matric_4 = norm(omega_new_face - omega_k_4);</span><br><span class="line">euclidean_matric_5 = norm(omega_new_face - omega_k_5);</span><br></pre></td></tr></table></figure>



<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.mitpressjournals.org/doi/pdfplus/10.1162/jocn.1991.3.1.71" target="_blank" rel="noopener">Eigenfaces for Recognition (mitpressjournals.org)</a></p>
<p><a href="https://en.wikipedia.org/wiki/Eigenface" target="_blank" rel="noopener">eigenface (wikipedia.org)</a></p>
<p><a href="https://ww2.mathworks.cn/matlabcentral/fileexchange/45915-eigenfaces-algorithm" target="_blank" rel="noopener">eigenfaces algorithm - File Exchange - MATLAB Central (mathworks.cn)</a></p>
<p><a href="https://zh.wikipedia.org/zh-hans/特征脸" target="_blank" rel="noopener">特征脸 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/26652435" target="_blank" rel="noopener">人脸识别之主成分分析（PCA） - 知乎 (zhihu.com)</a></p>
<p>本文地址： <a href="https://www.chimaoshu.top/基于PCA的人脸识别方法——特征脸法/">https://www.chimaoshu.top/基于PCA的人脸识别方法——特征脸法/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>PCA</tag>
        <tag>特征脸法</tag>
      </tags>
  </entry>
  <entry>
    <title>Microsoft Remote Desktop: We couldn&#39;t connect to the remote pc, this might be due to an expired password. Error code: 0x207</title>
    <url>/Microsoft-Remote-Desktop-we-couldn-t-connect-to-the-remote-pc-this-might-be-due-to-an-expired-password/</url>
    <content><![CDATA[<p>I got this problem when I was trying to login into my PC by remote desktop APP.</p>
<img src="https://raw.githubusercontent.com/chimaoshu/chimaoshu.github.io/master/Microsoft-Remote-Desktop-we-couldn-t-connect-to-the-remote-pc-this-might-be-due-to-an-expired-password/1.jpg" alt="problem" style="zoom:50%;" />

<p>I found many solutions on the Internet but none of them can solve my problem. Finally I found that it just because I have changed the main login email of my Microsoft account a few days ago, and I have to connect to my PC by my new email instead of the old one.</p>
<p>本文地址： <a href="https://www.chimaoshu.top/Microsoft-Remote-Desktop-we-couldn-t-connect-to-the-remote-pc-this-might-be-due-to-an-expired-password/">https://www.chimaoshu.top/Microsoft-Remote-Desktop-we-couldn-t-connect-to-the-remote-pc-this-might-be-due-to-an-expired-password/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>坑</category>
      </categories>
  </entry>
  <entry>
    <title>c#在使用protobuf过程中遇到的小坑</title>
    <url>/c-%E5%9C%A8%E4%BD%BF%E7%94%A8protobuf%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E5%9D%91/</url>
    <content><![CDATA[<p>写了 .proto 文件，编译成 c# 使用。在使用时，发现有一些特性一直没有补全。</p>
<p>比如<a href="https://developers.google.com/protocol-buffers/docs/csharptutorial" target="_blank" rel="noopener">文档</a>说到了：</p>
<blockquote>
<p>The collection type for repeated fields is always <code>RepeatedField&lt;T&gt;</code>. This type is like <code>List&lt;T&gt;</code> but with a few extra convenience methods, such as an <code>Add</code> overload accepting a collection of items, for use in colleciton initializers.</p>
</blockquote>
<p>但是我定新建一个 repeated 字段后并没有它说到的 Add() 方法，然后在网上查到了别人的代码的的确确用了 Add 方法。</p>
<p>查了挺久，没发现有人和我有类似问题，最后发现只是因为没有安装 protobuf 的依赖。</p>
<p>由于.proto生成的c#代码也是依赖于 Google.Protobuf 的，所以在没有安装之前一直没有补全，安装之后就好了。</p>
<p>本文地址： <a href="https://www.chimaoshu.top/c-在使用protobuf过程中遇到的小坑/">https://www.chimaoshu.top/c-在使用protobuf过程中遇到的小坑/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>坑</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title>base64编码字符串的长度计算方法</title>
    <url>/base64%E7%BC%96%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>我想在数据库中存一个被转化为Base64字符串的SHA256哈希值，我在想要用什么类型的值来存储，是用Text还是char[n]，这实际上和base64编码的长度有关，于是就查了下wiki。</p>
<h3 id="编码原理"><a href="#编码原理" class="headerlink" title="编码原理"></a>编码原理</h3><p>编码其实是基于一个64个数值的编码表（图源维基百科）:<br><img src="https://pic2.zhimg.com/80/v2-a5e95666494c4d739b9488596f47aa57_720w.png" alt="base64编码表" style="zoom: 67%;" /></p>
<p>也就是说每一个base64字符能够表示6bit的内容（2的6次方为64），换句话说，每4个base64字符（4 * 6 = 24）可以表示3（3 * 8 = 24）字节的内容。</p>
<a id="more"></a>

<p>如果原始的字节数不是3的倍数，比如4字节（剩余1字节）或者5字节（剩余2字节），则需要再末尾处理，一共可以分为2种情况。</p>
<ol>
<li><p>如果剩余1字节，需要补2字节（16bit）才是3的倍数。也就是要则补16个0，加上前面剩余的1字节（8bit），一共是24个bit，其中24个bit的前12bit（2*6）构成两个base64字符，剩下的12bit（2*6）全部是0，用两个等号 == 表示。</p>
</li>
<li><p>如果剩余2字节，需要补1字节（8bit）才是3的倍数。也就是要则补8个0，加上前面剩余的2字节（16bit），一共是24个bit，其中24个bit的前18bit（3*6）构成三个base64字符，剩下的6bit（1*6）全部是0，用一个等号 = 表示。</p>
</li>
</ol>
<p>如图所示（图源维基百科）：</p>
<p><img src="https://pic1.zhimg.com/80/v2-0fb504597c63950fc69eb0fb4f00b143_720w.png" alt="两种特殊情况"></p>
<p>也就是说，原始数据不够3字节就会补全到3个字节，这3个字节会相应地转化为4个base64字符。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>所以说最后的计算公式应该是：</p>
<p>向上取整(原始字节数 / 3) * 4</p>
<p>而SHA256的结果一共是256bit，也就是32字节，根据上述公式，最后的base64编码长度应该是44字节，应该使用char[44]存储。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>写个脚本验证一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"></span><br><span class="line">data = <span class="string">'test'</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'公式计算长度: '</span>, ceil(len(data) / <span class="number">3</span>) * <span class="number">4</span>)</span><br><span class="line">print(<span class="string">'实际编码长度: '</span>, len(b64encode(data.encode()).decode()))</span><br><span class="line"></span><br><span class="line">print(<span class="string">'SHA256编码后长度: '</span>,</span><br><span class="line">      len(b64encode(sha256(data.encode(<span class="string">'utf-8'</span>)).digest()).decode()))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">公式计算长度:  8</span><br><span class="line">实际编码长度:  8</span><br><span class="line">SHA256编码后长度:  44</span><br></pre></td></tr></table></figure>

<p>与理论值相符合。</p>
<p>参考资料：<a href="https://zh.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">Base64 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>本文地址： <a href="https://www.chimaoshu.top/base64编码字符串的长度计算方法/">https://www.chimaoshu.top/base64编码字符串的长度计算方法/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <tags>
        <tag>base64</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下无sudo安装protobuf的过程</title>
    <url>/CentOS%E4%B8%8B%E6%97%A0sudo%E5%AE%89%E8%A3%85protobuf%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>首先到release页面下载cpp的release：</p>
<p><a href="https://github.com/protocolbuffers/protobuf/releasesgithub.com" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releasesgithub.com</a></p>
<p>比如这种：</p>
<p><img src="https://pic2.zhimg.com/v2-205daf8233a455e774515aa2665f07b9_b.png" alt="img"></p>
<p>你可以手动下载后解压，或者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;releases&#x2F;download&#x2F;v3.14.0&#x2F;protobuf-cpp-3.14.0.tar.gz</span><br><span class="line">tar -zxvf protobuf-cpp-3.14.0.tar.gz</span><br><span class="line">cd protobuf-cpp-3.14.0</span><br></pre></td></tr></table></figure>

<p>检查依赖文件是否齐全：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">autoreconf -f -i</span><br></pre></td></tr></table></figure>

<p>否则后续make可能会出现这样的问题：</p>
<p><img src="https://pic3.zhimg.com/v2-beecf2dd6dac87f8c82e1ceabdb7bd52_b.jpeg" alt="img"></p>
<p>正常的流程是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;</span><br></pre></td></tr></table></figure>

<p>但是由于我们没有sudo权限，一方面不能使用bash运行configure，一方面无法写/usr/local/，所以这两个地方都需要做修改：</p>
<p>在./configure前面加上sh，后面的路径换成自己有权限的路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh .&#x2F;configure --prefix&#x3D;替换成一个你拥有权限的目录</span><br></pre></td></tr></table></figure>

<p>然后是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make check</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>即可等待安装完成，其中make和make check耗时较长，如果不愿意等，可以跳过make check 过程。</p>
<p>考虑到我们是在自己指定的目录下安装的，可能该目录没有被添加到本用户的环境变量下，因此可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>

<p>然后把目录路径添加到PATH的最后面：</p>
<p><img src="https://pic3.zhimg.com/v2-65401cbda4bb23fd7b4817401c0151e2_b.png" alt="img"></p>
<p>当初我弄到这里以为大功告成了，其实后面还有一大堆坑等着我，如果你写了一个protobuf的测试程序用原生g++进行编译，还会遇到大量的问题。</p>
<p>简单的说，你最好把protobuf手动添加到g++寻找头文件的路径、寻找动态、静态链接库的路径，否则后续编译可能会出很多奇怪的问题。当然你也可以在编译时使用-I、-L的命令，也许可以不用设置这些东西：</p>
<p>（这些也是在~/.bash_profile文件中设置的）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 环境变量，中间用冒号隔开</span><br><span class="line">PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;sbin:$HOME&#x2F;protobuf_lib&#x2F;bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line"># g++找头文件的路径</span><br><span class="line">CPLUS_INCLUDE_PATH&#x3D;$HOME&#x2F;protobuf_lib&#x2F;include</span><br><span class="line">export CPLUS_INCLUDE_PATH</span><br><span class="line"></span><br><span class="line"># 找动态链接库的路径</span><br><span class="line">LD_LIBRARY_PATH&#x3D;$HOME&#x2F;protobuf_lib&#x2F;lib:&#x2F;usr&#x2F;local&#x2F;lib:$HOME&#x2F;workspace&#x2F;MouseDB&#x2F;lib&#x2F;protobuf&#x2F;lib</span><br><span class="line">export LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line"># 找静态链接库的路径</span><br><span class="line">LIBRARY_PATH&#x3D;$HOME&#x2F;protobuf_lib&#x2F;lib:&#x2F;usr&#x2F;local&#x2F;lib:$HOME&#x2F;workspace&#x2F;MouseDB&#x2F;lib&#x2F;protobuf&#x2F;lib</span><br><span class="line">export LIBRARY_PATH</span><br><span class="line"></span><br><span class="line"># 找pkg_config的路径</span><br><span class="line">export PKG_CONFIG_PATH&#x3D;$HOME&#x2F;protobuf_lib&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure>

<p>最后再重新生效一下即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>

<p>BTW，如果后续编译出现google::protobuf::之类undefined的问题，请务必再编译时添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-lprotobuf -lpthread</span><br></pre></td></tr></table></figure>

<p>两个参数，比如我的Makefile是这样的：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># proto测试</span></span><br><span class="line">proto_test : test/test_proto/proto_test.cc</span><br><span class="line">	g++ -wall <span class="variable">$^</span> -g -o test/test_proto/<span class="variable">$@</span> -std=c++11 -lprotobuf -lpthread</span><br></pre></td></tr></table></figure>

<p>本文地址： <a href="https://www.chimaoshu.top/CentOS下无sudo安装protobuf的过程/">https://www.chimaoshu.top/CentOS下无sudo安装protobuf的过程/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
        <tag>c++</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析比特币中的数据结构</title>
    <url>/%E6%B5%85%E6%9E%90%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="浅析比特币中的数据结构"><a href="#浅析比特币中的数据结构" class="headerlink" title="浅析比特币中的数据结构"></a>浅析比特币中的数据结构</h1><h3 id="block-chain"><a href="#block-chain" class="headerlink" title="block chain"></a>block chain</h3><p>​        从整体上看，block chain是由哈希指针连成的链表。如图所示，除了创世纪块以外，每一个区块都有指向上一个区块的哈希指针，同时最新产生的区块也会有一个哈希指针指向他，只是还未被记录到下一个区块中。</p>
<img src="https://pic4.zhimg.com/80/v2-953960b5d02f6a43663efaa570e68504_1440w.jpeg" style="zoom:100%;" />

<p>​        值得一提的是，指向一个区块的哈希值由在此之前的所有区块共同作用。之所以说是“在此之前的所有区块共同作用”，是因为每个区块的block header都会存储上一个区块的哈希值，而计算区块的哈希值又需要整个block header的参与，上一个区块的哈希值自然包含在里面。</p>
<p>​        因此，只要某一个区块发生了篡改，后续的所有区块的哈希值都需要进行相应的修改，才能使得哈希指针能够对上。这个数据结构的好处是，只要存储最后一个哈希指针，就能检测前面所有的区块是否被篡改过，这是区块链不可篡改性的基石。</p>
<h3 id="block-body"><a href="#block-body" class="headerlink" title="block body"></a>block body</h3><p>​        顾名思义，block body是每一个区块的身体部分，它存储了由矿工打包的一些交易。整体上看，block body是由一课Merkle Tree构成的。</p>
<p>​        Merkle Tree，构成block body的数据结构。类似二叉树，但是这里的指针是哈希指针而非普通的指针。block body需要存储每一笔交易的具体内容，这些交易的具体内容都存储在Merkle Tree的叶子节点中。而每一个叶子节点都会生成哈希，兄弟节点之间的哈希会再进行一次哈希，生成父节点的值，以此类推，最终生成一个根哈希值（root hash），存储在block header中。</p>
<p><img src="https://pic4.zhimg.com/80/v2-f09851b71b080fcacdbddceac1ae272c_1440w.jpeg" alt=""></p>
<p>​        这种数据结构有什么好处呢？首先，我们只要存储一个root hash就能判断每一笔交易（即叶子节点）是否被篡改，这并不难理解。</p>
<p>​        其次，我们可以进行所谓的Merkle Proof，即证明某一笔交易是否被写到区块链中。在比特币这个去中心化的世界中，每个设备都是一个节点。挖矿的矿工属于全节点，他们的设备上存储了从创世纪块到现在的所有区块的block header与block body。而比特币钱包属于轻节点，与全节点不同的是，轻节点只存储block header，而不存储block body。前面说到，root hash会存储在block header里面，因此轻节点拥有root hash的内容。当你使用比特币钱包做了一次转账，轻节点（比特币钱包）需要检查转账是否被写在区块链里面，那么钱包会向全节点发起一次请求，由全节点返回对应路径上的哈希（如上图所示，如果想要检查a交易是否被写到区块里面，那么全节点会返回H(b)与H(H(c), H(d))），这样轻节点就可以在O(logN)的时间复杂度内算出root hash，检查其与本地存储的block header里面存储的信息是否一致，如果一致，则证明交易已经被存储到区块中。</p>
<h3 id="block-header"><a href="#block-header" class="headerlink" title="block header"></a>block header</h3><p>block header里面并没有亮眼的数据结构，但它存储的信息仍然十分重要，我们不妨看看：</p>
<p><img src="https://pic1.zhimg.com/80/v2-c1a62bf0251fb905cf44ead20d9337a5_1440w.png" alt=""></p>
<p>这是来自<a href="https://www.blockchain.com/btc/block的区块链信息，是7分钟前刚被矿工挖到的一个区块。可以看到里面存储了很多信息，比如我们前面提到的，整个区块链的哈希，以及Merkle" target="_blank" rel="noopener">https://www.blockchain.com/btc/block的区块链信息，是7分钟前刚被矿工挖到的一个区块。可以看到里面存储了很多信息，比如我们前面提到的，整个区块链的哈希，以及Merkle</a> root的哈希，还有出块的时间、挖矿得到的比特币奖励、矿工小费、协议版本等信息。</p>
<p>本文地址： <a href="https://www.chimaoshu.top/浅析比特币中的数据结构/">https://www.chimaoshu.top/浅析比特币中的数据结构/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>block chain</tag>
        <tag>bitcoin</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualXposed + Burp对微信抓包思路</title>
    <url>/VirtualXposed-Burp%E5%AF%B9%E5%BE%AE%E4%BF%A1%E6%8A%93%E5%8C%85%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="绕过微信证书检验"><a href="#绕过微信证书检验" class="headerlink" title="绕过微信证书检验"></a>绕过微信证书检验</h2><p>微信APP内置了对自家证书的校检，因此抓包时，微信会因为检测到自签名证书而拒绝联网。而Xposed能使用hook的方式来绕过它。</p>
<p>其中VirtualXposed是一个免root的不错选择：</p>
<p><a href="https://github.com/android-hacker/VirtualXposed" target="_blank" rel="noopener">https://github.com/android-hacker/VirtualXposedgithub.com</a></p>
<p>在项目的release页面可找到APK。</p>
<p>再使用VirtualXposed安装JustTrustMe插件：</p>
<p><a href="https://github.com/Fuzion24/JustTrustMe" target="_blank" rel="noopener">https://github.com/Fuzion24/JustTrustMegithub.com</a></p>
<p>在项目的release页面可找到APK，在安装APK时需选择“在VirtualXposed中安装”。</p>
<p>需要注意的时，VirtualXposed中的插件只会对VirtualXposed中的软件起作用，因此需要在VirtualXposed中也安装微信APP，建议到微信官网寻找32位的微信APP，不要使用64位APP或者使用应用商城的APK进行安装，否则很可能安装失败。</p>
<p>同样的，下载微信的APK后，选择“在VIrtualXposed中安装”即可。</p>
<h2 id="使用Burp进行抓包"><a href="#使用Burp进行抓包" class="headerlink" title="使用Burp进行抓包"></a>使用Burp进行抓包</h2><p>需要从电脑中把burp的证书导出并安装到手机里面：</p>
<p>在burp里面选择导出证书(export certificate)，然后修改后缀为.cer，传给手机后，选择证书，点击安装，随便勾选用途即可。</p>
<p><img src="https://pic4.zhimg.com/80/v2-00fd3f745bd1679fbbcce0e0abd0a45b_1440w.jpg" alt="img"></p>
<p>再次之后，打开手机的wifi–更多设置–开启代理，填你电脑的内网ip（要求手机和电脑在同一局域网）以及burp的监听端口就可以了。</p>
<img src="https://pic1.zhimg.com/80/v2-58e9fe93badfa2cfef1f42c7fd191514_1440w.jpg" alt="img" style="zoom: 25%;" />

<p>先开启burp的监听，然后开启VitualXposed中的微信即可开始对微信进行抓包。</p>
<p>无论是获取微信内置浏览器的cookies，或者对微信小程序进行测试，都可以采用此方法。</p>
<p>本文地址： <a href="https://www.chimaoshu.top/VirtualXposed-Burp对微信抓包思路/">https://www.chimaoshu.top/VirtualXposed-Burp对微信抓包思路/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <tags>
        <tag>抓包</tag>
        <tag>hook</tag>
        <tag>Xposed</tag>
        <tag>burp</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>STL中红黑树的用法探究及使用红黑树进行多字段索引的方法</title>
    <url>/STL%E4%B8%AD%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%94%A8%E6%B3%95%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h1 id="STL中红黑树的用法探究及使用红黑树进行多字段索引的方法"><a href="#STL中红黑树的用法探究及使用红黑树进行多字段索引的方法" class="headerlink" title="STL中红黑树的用法探究及使用红黑树进行多字段索引的方法"></a>STL中红黑树的用法探究及使用红黑树进行多字段索引的方法</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在造轮子，需要造分析型数据库。在关于热数据的设计中，对于到来的每一条热数据，我需要使用红黑树来维持热数据在内存中的有序索引。后来使用了STL中的红黑树，这个过程遇到了一大堆坑，网上能找到的资料又很少，所以记录了一下。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我需要维护多个字段的索引，比如这么一张图，我需要在红黑树上维护对于b、c、d三个字段的索引：</p>
<p><img src="https://pic4.zhimg.com/80/v2-3cd55671e26d7795aea719ed8e1c11f1_720w.png" alt="图源https://www.zhihu.com/question/304037770/answer/1287557228"></p>
<p>上图出自知乎问题<a href="https://www.zhihu.com/question/304037770/answer/1287557228" target="_blank" rel="noopener">mysql联合索引的B+树到底张什么样子啊？</a>下@<a href="https://www.zhihu.com/people/dawn-90-70" target="_blank" rel="noopener">Limit</a>的一个回答，这是innodb引擎下使用B+树的解决方法。但由于我现在维护的是热数据，并不需要进行磁盘IO，且只需要支持查询和插入的操作，所以我需要用红黑树来解决此问题。</p>
<a id="more"></a>

<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>我看了一些项目中的红黑树，比如Nginx、Redis、Linux中的红黑树，这些红黑树都是使用c语言写的，和c++代码风格迥异，后来我就想到了STL中的红黑树。STL中的map、set、multiset等容器的底层实现都是红黑树嘛，所以STL内当然也是有红黑树的代码了。</p>
<p><a href="https://zhuanlan.zhihu.com/p/87469768" target="_blank" rel="noopener">C++ STL源码剖析之红黑树</a>和<a href="https://zhuanlan.zhihu.com/p/87487629" target="_blank" rel="noopener">C++ STL源码剖析之set与multiset那些事</a>这两篇文章帮了我很多，在第一篇文章的最后，作者提到了STL中红黑树的使用方法：</p>
<blockquote>
<p>引入头文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;#include&lt;map&gt;或者&lt;set&gt;</span><br></pre></td></tr></table></figure>

<p>类定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;_Rb_tree&lt;int, int, _Identity&lt;int&gt;, less&lt;int&gt;&gt; itree;</span><br></pre></td></tr></table></figure>

<p>然后调用相应函数即可。</p>
</blockquote>
<p>其中有一些很关键的方法，比如插入操作：<br><img src="https://pic2.zhimg.com/80/v2-4964fbebff48fc531c5b8d71baca589c_720w.png" alt="插入操作"></p>
<p>其中与equal相关的方法，适用于红黑树中允许出现相同key值的情况，比如STL中的multiset；而unique相关方法适用于红黑树中不允许出现相同键值的情况，比如map或者set。</p>
<p>而带有下划线的方法，很容易让人联想到类中私有函数的命名规则。他们是函数内部实现用到的，因此我们不需要调用带有末尾下划线的方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_Rb_tree&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, _Identity&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; itree;</span><br><span class="line"></span><br><span class="line">itree._M_insert_equal(<span class="number">3</span>);</span><br><span class="line">itree._M_insert_equal(<span class="number">4</span>);</span><br><span class="line">itree._M_insert_equal(<span class="number">1</span>);</span><br><span class="line">itree._M_insert_equal(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = itree.begin(); it != itree.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>使用迭代器对map遍历的过程、或者说对红黑树遍历的过程，实际上是对红黑树做中序遍历，输出的顺序自然是从小到大的排列顺序。</p>
<p>剩下的还有一些方法，比如find、erase之类的，都和其他STL容器的用法差不多，不再赘述。</p>
<p><strong>上面只是最基本的红黑树用法，但实际上我们完全不知道_Rb_tree实例化时那一大堆模板参数的含义，就直接拿来用了，下面分析这些模板参数的含义。</strong></p>
<p>首先看STL源代码中的：<strong>stl_tree.h</strong></p>
<p>其中红黑树的模板参数定义如下，一共有5个模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Val, <span class="keyword">typename</span> _KeyOfValue,</span><br><span class="line">         <span class="keyword">typename</span> _Compare, <span class="keyword">typename</span> _Alloc = allocator&lt;_Val&gt; &gt;</span><br><span class="line">  class _Rb_tree</span><br><span class="line">  &#123;</span><br><span class="line">  ........</span><br></pre></td></tr></table></figure>

<p>在类的public定义中的typedef告诉了我们，前两个参数的含义其实是key和value：</p>
<p><img src="https://pic4.zhimg.com/80/v2-c7ad8d05687b09a4c41f17f10580e553_720w.png" alt="key和value"></p>
<p>第三个参数<strong>_KeyOfValue</strong>的含义花了我一整个上午和下午的时间才弄懂。其实<strong>_KeyOfValue</strong>通过重载函数调用运算符，即()，规定了通过value取得key的方式。</p>
<p>注意这里的key和value和map中的key和value很类似，但是稍微有些不同。我一开始就用map中的key-value的方式理解红黑树的key和value，导致代码一直编译不过。</p>
<p>这里红黑树的key其实是包含在value里面的，而map中的key和value是分开的。这么说可能有点抽象，举个例子，如果我们定义了一个map实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; m;</span><br></pre></td></tr></table></figure>

<p>那么在map中key就是int类型的，而value是char类型的，而在这个map底层的红黑树，它的key和value（也就是红黑树的前两个模板参数<strong>_Key</strong>和<strong>_Val</strong>）将会是<strong>int</strong>和<strong>pair&lt;int,  char&gt;</strong>。</p>
<p>这点我们可以通过阅读map的源代码（stl_map.h）发现：</p>
<p><img src="https://pic2.zhimg.com/80/v2-0adb789a8ff439d83f9fd978fd31d8d4_720w.png" alt="map中的模板参数"></p>
<p><strong>std::map&lt;int, char&gt;</strong>的参数就会如上图所示，然后接下来我们再观察map实例化红黑树所用的模板参数。</p>
<p>首先注意这里对value_type的定义，<strong>std::map&lt;int, char&gt;</strong>的<strong>value_type</strong>将会是<strong>std::pair&lt;int, char&gt;</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-fb433f411a189eb609aba3345b5962fe_720w.png" alt="value_type"></p>
<p>然后在下面就是map中对红黑树的定义：</p>
<p><img src="https://pic2.zhimg.com/80/v2-8609862b32723ee3da74878dac4ff1e5_720w.png" alt="map对红黑树的定义"></p>
<p>注意这里传入的是pair，而不是char本身。所以说红黑树的key是包含在value中的。我在这个地方被坑了好久，一直以为这里的key-value定义和map中一样，导致代码一直编译不过。</p>
<p>既然我们知道key是包含在value中的了，那么第三个参数<strong>_KeyOfValue</strong>其实就规定如何从value中取得key的过程。我们看回最初的那个红黑树的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_Rb_tree&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, _Identity&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; itree;</span><br></pre></td></tr></table></figure>

<p>这里第三个参数使用了<strong>_Identity</strong>，是什么意思呢？其实<strong>_Identity</strong>是“<strong>stl_function.h</strong>”中定义的一个结构体：</p>
<p><img src="https://pic3.zhimg.com/80/v2-63014f2c4682cabbbbddd816eb31adc3_720w.png" alt="_Identity"></p>
<p>其中的unary_function是一个结构体，它定义了一个二元运算的输入类与输出类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  This is one of the @link functors functor base classes@endlink.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Arg, <span class="keyword">typename</span> _Result&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">unary_function</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/// @c argument_type is the type of the argument</span></span><br><span class="line">    <span class="keyword">typedef</span> _Arg 	argument_type;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @c result_type is the return type</span></span><br><span class="line">    <span class="keyword">typedef</span> _Result 	result_type;  </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>但其实这里可以不去管unary_function，因为它的出现与否和红黑树没啥关系。我们要的其实是<strong>_Identity</strong>中的重载函数调用运算符（即对()的重载）。_Identity中对()进行了重载，最终的结果就是，返回了传入的参数本身。那么</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_Rb_tree&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, _Identity&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; itree;</span><br></pre></td></tr></table></figure>

<p>中的<strong>_Identity<int></strong>的含义其实就很明显了，他的意思就是，当我们插入1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">itree._M_insert_equal(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>那么实际上1本身既是key也是value（map中的value含义）。注意红黑树中的key用于对节点进行排序，而value则是我们要存储的值。</p>
<p>我们回到map中对第三个模板参数的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _Rb_tree&lt;key_type, value_type, _Select1st&lt;value_type&gt;,</span><br><span class="line">	key_compare, _Pair_alloc_type&gt; _Rep_type;</span><br></pre></td></tr></table></figure>

<p>这里第三个模板参数用的是： <strong>_Select1st<value_type></strong>，我们不妨看一下它的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Pair&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Select1st</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> unary_function&lt;_Pair, <span class="keyword">typename</span> _Pair::first_type&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">typename</span> _Pair::first_type&amp;</span><br><span class="line">      <span class="keyword">operator</span>()(_Pair&amp; __x) <span class="keyword">const</span></span><br><span class="line">      &#123; <span class="keyword">return</span> __x.first; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> _Pair::first_type&amp;</span><br><span class="line">      <span class="keyword">operator</span>()(<span class="keyword">const</span> _Pair&amp; __x) <span class="keyword">const</span></span><br><span class="line">      &#123; <span class="keyword">return</span> __x.first; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Pair2&gt;</span><br><span class="line">        <span class="keyword">typename</span> _Pair2::first_type&amp;</span><br><span class="line">        <span class="keyword">operator</span>()(_Pair2&amp; __x) <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> __x.first; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Pair2&gt;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">typename</span> _Pair2::first_type&amp;</span><br><span class="line">        <span class="keyword">operator</span>()(<span class="keyword">const</span> _Pair2&amp; __x) <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> __x.first; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>上面的unary_function与红黑树无关，可以不管，只看对运算符的重载。仔细一看会发现，其实他就是传入一个pair，然后return pair.first，仅此而已。我们前面说到第三个模板参数其实是规定了从value中取出key的过程，当我们使用map&lt;int,char&gt;时，获得key的过程其实就是从pair&lt;int,char&gt;中取出第一个数的过程。</p>
<p>有<strong>_Select1st</strong>，自然也就有<strong>_Select2nd</strong>，_Select2nd的操作当然就是取出第二个元素。这样一来第三个模板参数<strong>_KeyOfValue</strong>就很清晰了，他其实就是一个结构体，然后对()运算符进行了重载，规定了从value中取出key的方法。当你在STL的源代码中看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_KeyOfValue()(value)</span><br></pre></td></tr></table></figure>

<p>其实就是通过value获取key的过程了。注意，如果要自己写第三个模板元参数，那么在重载()符号时，记得返回值必须是const类型的引用，比如const int&amp;，关于这点可以参考：<a href="https://www.cnblogs.com/sandychn/p/12334194.html" target="_blank" rel="noopener">https://www.cnblogs.com/sandychn/p/12334194.html</a> ，这篇文章也帮了我很多。</p>
<p>最后是第四个参数：_Compare</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Val, <span class="keyword">typename</span> _KeyOfValue,</span><br><span class="line">         <span class="keyword">typename</span> _Compare, <span class="keyword">typename</span> _Alloc = allocator&lt;_Val&gt; &gt;</span><br></pre></td></tr></table></figure>

<p>顾名思义，这个参数自然和大小比较有关：当我们使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_Rb_tree&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, _Identity&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; itree;</span><br></pre></td></tr></table></figure>

<p>其实这里的 less<int>就是类似前面说的那些结构体，重载了()运算符，传入两个参数a、b，返回 a &lt; b的布尔值。</p>
<p>回头再看看map的源代码，可以看到map的默认大小比较方法其实也是less：</p>
<p><img src="https://pic4.zhimg.com/80/v2-e9235583ba36c4e3ec12780360d0eeef_720w.png" alt="less"></p>
<p>附上less的代码，参考前面所说的，这里应该不难看懂：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// One of the @link comparison_functors comparison functors@endlink.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp, _Tp, <span class="keyword">bool</span>&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">operator</span>()(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y) <span class="keyword">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>当然这里我们也可以自己写一套大小比较逻辑。</p>
<p>红黑树的最后一个参数<strong>_Alloc</strong>和内存分配有关，一般我们保持其默认值就可以了。</p>
<p>至此，我们分析了红黑树实例化时不同模板元参数的含义，现在我们可以试试解决文章最开头提出的问题：</p>
<p>怎么在红黑树上构建图中所示b、c、d字段的索引：</p>
<p><img src="https://pic4.zhimg.com/80/v2-3cd55671e26d7795aea719ed8e1c11f1_720w.png" alt="图源https://www.zhihu.com/question/304037770/answer/1287557228"></p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>根据我们分析的内容，我们首先需要一个结构体来存储上述所示的三个索引值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keys</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    keys(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span><br><span class="line">        : a(a), b(b), c(c)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后自定义一套比较规则：优先比较a、其次比较b、最后比较c，所以我简单地写了一大堆很笨的嵌套if：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_less</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">operator</span>()(<span class="keyword">const</span> keys &amp;x, <span class="keyword">const</span> keys &amp;y) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.a &lt; y.a)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.a &gt; y.a)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.b &lt; y.b)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x.b &gt; y.b)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.c &lt; y.c)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后就可以实例化一个类了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_Rb_tree&lt;<span class="keyword">const</span> keys, </span><br><span class="line">    pair&lt;<span class="keyword">const</span> keys, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;, </span><br><span class="line">    _Select1st&lt;pair&lt;<span class="keyword">const</span> keys, <span class="keyword">char</span>&gt; &gt;, </span><br><span class="line">    my_less &gt; itree;</span><br></pre></td></tr></table></figure>

<p>然后把我们前面的参数插入进去：</p>
<p><img src="https://pic4.zhimg.com/80/v2-3cd55671e26d7795aea719ed8e1c11f1_720w.png" alt="图源https://www.zhihu.com/question/304037770/answer/1287557228"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">itree._M_insert_unique(pair&lt;<span class="keyword">const</span> keys, <span class="built_in">string</span>&gt;(keys(<span class="number">13</span>,<span class="number">12</span>,<span class="number">4</span>),<span class="string">"dll"</span>));</span><br><span class="line">itree._M_insert_unique(pair&lt;<span class="keyword">const</span> keys, <span class="built_in">string</span>&gt;(keys(<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>),<span class="string">"doc"</span>));</span><br><span class="line">itree._M_insert_unique(pair&lt;<span class="keyword">const</span> keys, <span class="built_in">string</span>&gt;(keys(<span class="number">13</span>,<span class="number">16</span>,<span class="number">5</span>),<span class="string">"img"</span>));</span><br><span class="line">itree._M_insert_unique(pair&lt;<span class="keyword">const</span> keys, <span class="built_in">string</span>&gt;(keys(<span class="number">12</span>,<span class="number">14</span>,<span class="number">3</span>),<span class="string">"xml"</span>));</span><br><span class="line">itree._M_insert_unique(pair&lt;<span class="keyword">const</span> keys, <span class="built_in">string</span>&gt;(keys(<span class="number">12</span>,<span class="number">14</span>,<span class="number">3</span>),<span class="string">"txt"</span>));</span><br><span class="line">itree._M_insert_unique(pair&lt;<span class="keyword">const</span> keys, <span class="built_in">string</span>&gt;(keys(<span class="number">13</span>,<span class="number">16</span>,<span class="number">1</span>),<span class="string">"txt"</span>));</span><br><span class="line">itree._M_insert_unique(pair&lt;<span class="keyword">const</span> keys, <span class="built_in">string</span>&gt;(keys(<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>),<span class="string">"pdf"</span>));</span><br></pre></td></tr></table></figure>

<p>最后使用迭代器遍历输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = itree.begin(); it != itree.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (*it).first.a &lt;&lt; <span class="string">' '</span> &lt;&lt; (*it).first.b &lt;&lt; <span class="string">' '</span></span><br><span class="line">                  &lt;&lt; (*it).first.c &lt;&lt; <span class="string">' '</span> &lt;&lt; (*it).second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 5 4 doc</span><br><span class="line">5 3 6 pdf</span><br><span class="line">12 14 3 xml</span><br><span class="line">13 12 4 dll</span><br><span class="line">13 16 1 txt</span><br><span class="line">13 16 5 img</span><br></pre></td></tr></table></figure>

<p>最后的结果完全我想要的顺序：优先按第一个索引排列，相同值看第二个索引，以此类推。</p>
<p>这部分内容坑了我好久，在网上能找到的资料也不多，所以我把这个过程记录下来了，感谢给我提供思路的那些文章和回答。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/87469768" target="_blank" rel="noopener">C++ STL源码剖析之红黑树 - Francis的文章 - 知乎</a> </p>
<p><a href="https://zhuanlan.zhihu.com/p/87487629" target="_blank" rel="noopener">C++ STL源码剖析之set与multiset那些事 - Francis的文章 - 知乎</a></p>
<p><a href="https://www.zhihu.com/question/304037770/answer/1287557228" target="_blank" rel="noopener">mysql联合索引的B+树到底张什么样子啊？ - Limit的回答 - 知乎</a></p>
<p><a href="https://www.cnblogs.com/sandychn/p/12334194.html" target="_blank" rel="noopener">STL中_Rb_tree的探索</a></p>
<p>本文地址： <a href="https://www.chimaoshu.top/STL中红黑树的用法探究/">https://www.chimaoshu.top/STL中红黑树的用法探究/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
        <tag>红黑树</tag>
        <tag>RBTree</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>使用DDNS脚本对阿里云提供的域名进行动态解析</title>
    <url>/%E4%BD%BF%E7%94%A8DDNS%E8%84%9A%E6%9C%AC%E5%AF%B9%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="使用DDNS解析脚本对阿里云提供的域名进行动态解析"><a href="#使用DDNS解析脚本对阿里云提供的域名进行动态解析" class="headerlink" title="使用DDNS解析脚本对阿里云提供的域名进行动态解析"></a>使用DDNS解析脚本对阿里云提供的域名进行动态解析</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前用bitwarden_rs的docker容器+Nginx反向代理，并设置了https，把bitwarden服务器部署到了自己的电脑上，在校园网中提供服务–只要我的手机连上学校的wifi，就可以访问到我电脑上的bitwarden服务、</p>
<p><a href="https://zhuanlan.zhihu.com/p/158794535" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/158794535</a></p>
<p>但是我遇到了一个麻烦的问题，就是电脑在校园网的ip偶尔会发生变化，每次变化就要手动登陆阿里云去修改DNS的解析ip地址，这很麻烦。所以我决定使用DDNS来完成解析ip的动态切换。</p>
<a id="more"></a>

<p>推荐Github上这个项目：<br><a href="https://github.com/NewFuture/DDNS" target="_blank" rel="noopener">https://github.com/NewFuture/DDNS</a><br>支持许多服务商的API，功能也比较完善。<br><img src="https://img-blog.csdnimg.cn/20201218132341742.png" alt="支持的DNS服务商"><br>以阿里云为例，进行介绍。大概的思路就是创建一个RAM子账户，然后授予这个账户通过API解析DNS的权限，最后把账户的ACCESS_ID和ACCESS_KEY复制到配置文件中。</p>
<p><a href="https://help.aliyun.com/document_detail/28637.html" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/28637.html</a><br>按照文档给出的方式，创建子账号，注意创建子账号的时候需要选择“编程访问”。<br><img src="https://img-blog.csdnimg.cn/20201215131413482.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201218213338242.png" alt="在这里插入图片描述"></p>
<p>之后给RAM子账号授权，选择两个管理DNS的权限：<br><img src="https://img-blog.csdnimg.cn/20201218212451329.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201218212933821.png" alt="在这里插入图片描述"><br>之后来到Github项目的release页，选择exe或者python都可以，配置的参数可以看官方文档，需要注意的是，id填的是你的ACCESS_ID，token填的是你的ACCESS_TOKEN（以阿里云为例）。</p>
<p>最后在bitwarden启动前，先调用脚本对DNS进行解析设定。这样每次启动bitwarden就不用一直手动修改域名解析设定了。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ProcessName</span> = <span class="string">"docker desktop"</span></span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">get-process</span> <span class="variable">$ProcessName</span> <span class="literal">-ErrorAction</span> SilentlyContinue) <span class="operator">-eq</span> <span class="variable">$Null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    echo <span class="string">"Docker is not running,strating...."</span> </span><br><span class="line">    start <span class="string">"Docker Desktop"</span></span><br><span class="line">    sleep <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">    echo <span class="string">"Dcoker is running."</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">docker start bitwarden</span><br><span class="line"></span><br><span class="line">echo <span class="string">"resolve DNS address...."</span></span><br><span class="line">.\DNS.lnk</span><br><span class="line"></span><br><span class="line">echo <span class="string">"start Nginx..."</span></span><br><span class="line">.\nginx</span><br><span class="line"></span><br><span class="line">echo <span class="string">"ok"</span></span><br></pre></td></tr></table></figure>


<p>本文地址： <a href="https://www.chimaoshu.top/使用DDNS脚本对阿里云域名进行动态域名解析/">https://www.chimaoshu.top/使用DDNS脚本对阿里云域名进行动态域名解析/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>DDNS</tag>
      </tags>
  </entry>
  <entry>
    <title>非常简单的sqlite入门教程</title>
    <url>/%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%E7%9A%84sqlite%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="写给新人的简单sqlite入门教程"><a href="#写给新人的简单sqlite入门教程" class="headerlink" title="写给新人的简单sqlite入门教程"></a>写给新人的简单sqlite入门教程</h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>进入sqlite的官网：<a href="https://www.sqlite.org/index.html" target="_blank" rel="noopener">https://www.sqlite.org/index.html</a></p>
<a id="more"></a>

<p>点击download：<br><img src="https://img-blog.csdnimg.cn/20201024182850910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70#pic_center" alt="sqlite下载"><br><img src="https://img-blog.csdnimg.cn/20201024183129124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>下载后解压。</p>
<p>注：如果想要在任意文件目录都可以使用sqlite，请把sqlite所在的文件夹，也就是你解压的文件夹，加入到环境变量path中。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>解压后在解压文件夹下打开cmd（或者打开cmd切换到解压文件夹），输入命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite3 students.db</span><br></pre></td></tr></table></figure>
<p>表示使用sqlite3.exe来连接一个叫students的databse（db）。</p>
<p>然后输入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">create table <span class="title">class1</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ID	  <span class="keyword">int</span>		primary key 	<span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="function"><span class="params">	name  <span class="built_in">text</span>						<span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="function"><span class="params">	score <span class="keyword">int</span> 						<span class="keyword">not</span> null</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个过程发生了什么？</p>
<p>你在刚才打开的数据库中创建了一张表，表的名字是class1，定义表中的每一行的数据（即每一个学生的信息）分别为：ID、name、score。</p>
<p>其中ID的类型是int，而name的类型为text，socre的类型为int。后面的not null 表示不允许他们的值为空。而ID后面有个primary key，表示数据在存储时默认会以ID从小到大的顺序进行存储。</p>
<p>现在你可以输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.tables</span><br></pre></td></tr></table></figure>
<p>来查看你刚刚建立的那张表，输入后你会看到你刚刚创建的这张表的名字。</p>
<p>接下来我们尝试把这三个学生的数据录入存到表中：<br>姓名：张三      序号：1     分数：50<br>姓名：李四         序号：2     分数：80<br>姓名：王五      序号：3     分数：100</p>
<p>输入这个指令：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">insert into class1 (ID, name, score) values(1, '张三', 50);</span><br></pre></td></tr></table></figure>
<p>这行指令的意思是，把ID=1，name=’张三’,score=50的信息，插入到了class1这个表中。</p>
<p>按下回车键，张三的信息就会被录入到数据库中了。如何查看此时的数据库中的数据呢？</p>
<p>你只需要：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">select * from class1;</span><br></pre></td></tr></table></figure>
<p>这行指令可以查看整个class1表的所有数据。</p>
<p>类似的，你不妨试一试把李四和王五的数据也录入到数据库。</p>
<p>我们知道了”select * from class1;”可以查看整个数据库的所有数据，那么如何只查看李四一人的数据呢？<br>你需要：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">select * from class1 where name='王五';</span><br></pre></td></tr></table></figure>
<p>这时候你就可以从class1中取出name=’王五’的人的数据了。<br>那么前面这个星号*是什么意思呢？<br>他表示取出王五的所有数据（也就是ID、姓名、分数）。</p>
<p>如果我只需要取出王五的分数，不需要其他数据，那么我可以：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">select score from class1 where name='王五';</span><br></pre></td></tr></table></figure>
<p>如果我要取出王五的ID和分数，那么我可以：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">select ID,score from class1 where name='王五';</span><br></pre></td></tr></table></figure>
<p>如果我要从class1这个表中删除王五的数据，那么我可以：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">delete from class1 where name='王五'</span><br></pre></td></tr></table></figure>
<p>其实SQL语句的形式很接近自然语言，所以我们很容易看懂每句话的意思。至此，你已经学会了基本的创建、增删、查询的操作。</p>
<p>进一步学习可以参考：<a href="https://www.runoob.com/sqlite/sqlite-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/sqlite/sqlite-tutorial.html</a></p>
<p>本文地址： <a href="https://www.chimaoshu.top/非常简单的sqlite入门教程/">https://www.chimaoshu.top/非常简单的sqlite入门教程/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sqlite</tag>
        <tag>sql</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>DS栈—波兰式，逆波兰式</title>
    <url>/DS%E6%A0%88%E2%80%94%E6%B3%A2%E5%85%B0%E5%BC%8F%EF%BC%8C%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="波兰式，逆波兰式"><a href="#波兰式，逆波兰式" class="headerlink" title="波兰式，逆波兰式"></a>波兰式，逆波兰式</h1><h2 id="某校数据结构课一道OJ题"><a href="#某校数据结构课一道OJ题" class="headerlink" title="某校数据结构课一道OJ题"></a>某校数据结构课一道OJ题</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>表达式有三种表示方法，分别为：</p>
<p>前缀表示(波兰式)：运算符+操作数1+操作数2</p>
<p>中缀表示：操作数1+运算符+操作数2</p>
<a id="more"></a>

<p>后缀表示(逆波兰式)：操作数1+操作数2+运算符</p>
<p>例如：a +b * (c -d ) - e/f</p>
<p>波兰式：-+a*b-cd/ef   （运算符在操作数的前面，用递归计算波兰式）</p>
<p>中缀式：a+b*c-d-e/f  </p>
<p>逆波兰式：abcd-*+ef/  （运算符在操作数的后面，用栈计算逆波兰式）</p>
<p>​    中缀表示就是原表达式去掉扣号。    </p>
<p>根据表达式求波兰式、逆波兰式都是教材第三章表达式求值的思想。   </p>
<p>​    求波兰式，需要操作数栈(注意不是计算结果入栈，有计算式入栈)，运算符栈。区别在于从后往前扫描表达式，‘(’ 换成’)’,’(‘换成‘)’。栈顶运算符优先级&gt;新读入运算符优先级出栈，表3.1中的相同运算符优先级&gt;（从左往右计算）改为&lt;，例如栈顶为‘+‘，新读入的为‘+’，则栈顶优先级&lt;新读入的优先级。</p>
<p>求逆波兰式，只需要运算符栈。操作数直接输出，操作符按表3.1优先级顺序出栈，输出。</p>
<p>​    输入表达式，求其波兰式和逆波兰式。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p> 测试次数</p>
<p>每组测试数据一行，一个合法表达式</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p> 对每组测试数据，输出两行</p>
<p>第一行，表达式的波兰表示</p>
<p>第二行，表达式的逆波兰表示</p>
<p>不同组测试数据间以空行分隔。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4+2*3-10&#x2F;5</span><br><span class="line">12+3*5+(2+10)*5</span><br></pre></td></tr></table></figure>



<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\- + 4 * 2 3 &#x2F; 10 5</span><br><span class="line">4 2 3 * + 10 5 &#x2F; -</span><br><span class="line"></span><br><span class="line">+ + 12 * 3 5 * + 2 10 5</span><br><span class="line">12 3 5 * + 2 10 + 5 * +</span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> space <span class="meta-string">' '</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPriority</span><span class="params">(<span class="keyword">char</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (temp != <span class="string">'+'</span> &amp;&amp; temp != <span class="string">'-'</span> &amp;&amp; temp != <span class="string">'*'</span> &amp;&amp; temp != <span class="string">'/'</span> &amp;&amp; temp != <span class="string">'('</span> &amp;&amp; temp != <span class="string">')'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆波兰式只要一个运算符栈就可以，数字直接输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reservePolish</span><span class="params">(<span class="built_in">string</span> expression)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; operatorStack; <span class="comment">// 运算符栈</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> theLastCharactorIsNumber = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> theFirst = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = expression[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'+'</span> || ch == <span class="string">'-'</span> || ch == <span class="string">'*'</span> || ch == <span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (operatorStack.empty() || operatorStack.top() == <span class="string">'('</span>)</span><br><span class="line">                operatorStack.push(ch);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 逆波兰式这里有=，而波兰式没有=</span></span><br><span class="line">                <span class="keyword">while</span> (getPriority(operatorStack.top()) &gt;= getPriority(ch))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!theFirst)</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; space;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; operatorStack.top();</span><br><span class="line">                    operatorStack.pop();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (operatorStack.empty())</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                operatorStack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            theLastCharactorIsNumber = <span class="literal">false</span>;</span><br><span class="line">            theFirst = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'('</span>) <span class="comment">// 这个不能做first</span></span><br><span class="line">        &#123;</span><br><span class="line">            operatorStack.push(ch);</span><br><span class="line">            theLastCharactorIsNumber = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">')'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!operatorStack.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (operatorStack.top() == <span class="string">'('</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    operatorStack.pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!theFirst)</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; space;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; operatorStack.top();</span><br><span class="line">                    operatorStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            theLastCharactorIsNumber = <span class="literal">false</span>;</span><br><span class="line">            theFirst = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (theLastCharactorIsNumber || theFirst)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">flush</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; space &lt;&lt; ch &lt;&lt; <span class="built_in">flush</span>;</span><br><span class="line"></span><br><span class="line">            theLastCharactorIsNumber = <span class="literal">true</span>;</span><br><span class="line">            theFirst = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (!operatorStack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!theFirst)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; space;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; operatorStack.top();</span><br><span class="line">        operatorStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 波兰式：把)和(倒换，然后从后往前读,&gt;=变成&gt;，最后逆序输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">polish</span><span class="params">(<span class="built_in">string</span> expression)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; operatorStack; <span class="comment">// 运算符栈</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; output;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> theLastCharactorIsNumber = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后往前</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = expression.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = expression[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'+'</span> || ch == <span class="string">'-'</span> || ch == <span class="string">'*'</span> || ch == <span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (operatorStack.empty() || operatorStack.top() == <span class="string">')'</span>)</span><br><span class="line">                operatorStack.push(ch);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 逆波兰式这里有=，而波兰式没有=</span></span><br><span class="line">                <span class="keyword">while</span> (getPriority(operatorStack.top()) &gt; getPriority(ch))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; operatorStack.top() &lt;&lt; " ";</span></span><br><span class="line">                    output.push(space);</span><br><span class="line">                    output.push(operatorStack.top());</span><br><span class="line">                    operatorStack.pop();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (operatorStack.empty())</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                operatorStack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">')'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            operatorStack.push(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'('</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!operatorStack.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (operatorStack.top() == <span class="string">')'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    operatorStack.pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; operatorStack.top() &lt;&lt; " ";</span></span><br><span class="line">                    output.push(space);</span><br><span class="line">                    output.push(operatorStack.top());</span><br><span class="line">                    operatorStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从后往前读，而前一个读取的是数字，所以要</span></span><br><span class="line">            <span class="keyword">if</span> (!theLastCharactorIsNumber)</span><br><span class="line">            &#123;</span><br><span class="line">                output.push(space);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            output.push(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        theLastCharactorIsNumber = isNumber(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!operatorStack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; operatorStack.top() &lt;&lt; " ";</span></span><br><span class="line">        output.push(space);</span><br><span class="line">        output.push(operatorStack.top());</span><br><span class="line">        operatorStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒叙输出</span></span><br><span class="line">    <span class="keyword">while</span> (!output.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = output.top();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断栈是否只剩最后一个空格（不输出最后一个空格）</span></span><br><span class="line">        <span class="keyword">if</span> (temp == space)</span><br><span class="line">        &#123;</span><br><span class="line">            output.pop();</span><br><span class="line">            <span class="keyword">if</span> (output.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; space &lt;&lt; <span class="built_in">flush</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">flush</span>;</span><br><span class="line">        output.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tryTimes;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; tryTimes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tryTimes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> expression;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; expression;</span><br><span class="line"></span><br><span class="line">        polish(expression);</span><br><span class="line">        reservePolish(expression);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i != tryTimes - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<p><a href="https://blog.csdn.net/linraise/article/details/20459751" target="_blank" rel="noopener">https://blog.csdn.net/linraise/article/details/20459751</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/141207867" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/141207867</a></p>
<p>本文地址： <a href="https://www.chimaoshu.top/DS栈—波兰式，逆波兰式/">https://www.chimaoshu.top/DS栈—波兰式，逆波兰式/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>波兰式</tag>
        <tag>逆波兰式</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>为1M小水管的Minecraft服务器加速的各种尝试</title>
    <url>/%E4%B8%BA1M%E5%B0%8F%E6%B0%B4%E7%AE%A1%E7%9A%84Minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A0%E9%80%9F/</url>
    <content><![CDATA[<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>阿里云的学生机，10块钱一个月的那种，只有1Mbps的带宽。1Mbps是什么概念呢？就是公网下行带宽最大是<strong>1×1024÷8 = 128 kb/s</strong>，每秒最多128kb的速度，开mc服务器基本顶不住。一个只有三人的私人服务器，差不多两人就能把带宽占满，三人就开始卡，如何解决呢？</p>
<a id="more"></a>

<h3 id="首先从Minecraft服务器的设置出发"><a href="#首先从Minecraft服务器的设置出发" class="headerlink" title="首先从Minecraft服务器的设置出发"></a>首先从Minecraft服务器的设置出发</h3><p><a href="https://minecraft-zh.gamepedia.com/Server.properties" target="_blank" rel="noopener">Minecraft维基百科</a>上关于服务器的设置文件<strong>server.properties</strong>讲的非常清楚，其中有两处地方可以大大减少服务器的带宽，他们分别是：</p>
<p><img src="https://img-blog.csdnimg.cn/20200717083226118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200717083357514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200717110712671.png" alt="在这里插入图片描述"></p>
<p>其中<strong>network-compression-threshold</strong>与数据包的压缩有关，他的本质就是拿CPU资源去换带宽资源，我的设置是0，即压缩全部数据包。</p>
<p>而<strong>view-distance</strong>是玩家的视野距离，我一直开着1（最低配置），不过玩家几乎是感觉不到它的存在的，可以放心调低。</p>
<p>而第三个是Linux专用的，可以优化数据包的收发。</p>
<p>通过这两个配置，我的Minecraft服务器已经基本够3人玩了，但是3人的时候还是会轮流变卡，一看阿里云后台的公网出口带宽，都是全满的。还是需要解决问题！</p>
<h3 id="在本机运行Minecraft服务器，使用阿里云的服务器做中转？"><a href="#在本机运行Minecraft服务器，使用阿里云的服务器做中转？" class="headerlink" title="在本机运行Minecraft服务器，使用阿里云的服务器做中转？"></a>在本机运行Minecraft服务器，使用阿里云的服务器做中转？</h3><p>用frp进行端口映射，把本地的25565端口映射到云端上，这样用本机的CPU就会好一些，并且frp可以做压缩。</p>
<p>最终效果：比直接开在云端还慢，因为公网下行数据实际上更多了，阿里云需要在我的电脑和朋友的电脑之间做数据中转。效果很差，放弃了，强烈不推荐。</p>
<h3 id="P2P的Minecraft服务器？"><a href="#P2P的Minecraft服务器？" class="headerlink" title="P2P的Minecraft服务器？"></a>P2P的Minecraft服务器？</h3><p>既然做中转会受到阿里云的带宽限制，那如果我们使用P2P呢？直接在两台电脑直接建立对等连接，而云服务器只在一开始负责帮两台电脑建立连接，等到连接建立后，数据是不经过阿里云做中转的，直接在我的朋友的电脑直接流通。</p>
<p>于是我开始着手寻找能够进行P2P打洞的软件，刚开始用了frp的一个P2P打洞功能，叫做XTCP，服务端配置是这样的：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">bind_udp_port</span> = <span class="number">7001</span></span><br></pre></td></tr></table></figure>

<p>我的电脑客户端配置是这样的：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># 你的frp服务器的公网ip</span></span><br><span class="line"><span class="attr">server_addr</span> = xx.xx.xx.xxx</span><br><span class="line"><span class="comment"># 你的frp服务器的默认端口</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[mc]</span></span><br><span class="line"><span class="attr">type</span> = xtcp</span><br><span class="line"><span class="comment"># 只有 sk 一致的用户才能访问到此服务</span></span><br><span class="line"><span class="attr">sk</span> = oc7D!PgY&amp;guFBPwoEfKq</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># 远程桌面的本地端口号</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">25565</span></span><br></pre></td></tr></table></figure>

<p>朋友的电脑客户端的配置是这样的：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># 你的frp服务器的公网ip</span></span><br><span class="line"><span class="attr">server_addr</span> = xx.xx.xx.xx</span><br><span class="line"><span class="comment"># 你的frp服务器的默认端口</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[mc_visitor]</span></span><br><span class="line"><span class="attr">type</span> = xtcp</span><br><span class="line"><span class="comment"># stcp 的访问者</span></span><br><span class="line"><span class="attr">role</span> = visitor</span><br><span class="line"><span class="comment"># 要访问的 stcp 代理的名字</span></span><br><span class="line"><span class="attr">server_name</span> = mc</span><br><span class="line"><span class="comment"># 只有 sk 一致的用户才能访问到此服务</span></span><br><span class="line"><span class="attr">sk</span> = oc7D!PgY&amp;guFBPwoEfKq</span><br><span class="line"><span class="comment"># 绑定本地端口用于访问 远程桌面 服务</span></span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure>

<p>这样，（理论上）只要朋友访问127.0.0.1:6000就能访问到我的电脑上的Minecraft服务器了。然而最终失败了，连接不能顺利地建立。本来frp的打洞功能也非常不成熟，受到NAT类型的影响。</p>
<p><strong>然后我又开始寻找其他的P2P解决方案，最终找到了NPS</strong></p>
<p>和frp一样，也是Github上开源的项目，也都是用Go语言写的。</p>
<p><a href="https://github.com/ehang-io/nps" target="_blank" rel="noopener">https://github.com/ehang-io/nps</a></p>
<p>于是开始了我的部署之路，安装过程只要照着(官方教程)[<a href="https://ehang-io.github.io/nps/#/install]来就行了。最终登陆管理面板是这样的：" target="_blank" rel="noopener">https://ehang-io.github.io/nps/#/install]来就行了。最终登陆管理面板是这样的：</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200717102417522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="管理面板"></p>
<p>然后照着官方教程，创建一个客户端：</p>
<p><img src="https://img-blog.csdnimg.cn/20200717103015637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="新建客户端"></p>
<p>参数可以随便填，然后复制最下面红色的那行命令：</p>
<p><img src="https://img-blog.csdnimg.cn/20200717103158542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="复制"></p>
<p>然后下载nps的客户端到我运行Minecraft服务器的本机电脑，打开cmd切换到客户端exe所在的目录下，把命令复制进去运行。注意这里不能使用PowerShell，否则会连接不上。如果cmd显示无法运行，就把那行命令前面的./去掉。</p>
<p>之后去创建一个P2P连接，客户端ID要和上面我们创建的客户端的ID一致。</p>
<p><img src="https://img-blog.csdnimg.cn/20200717103614392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="P2P连接"></p>
<p>然后像前面一样，复制最下面的命令：</p>
<p><img src="https://img-blog.csdnimg.cn/20200717103831997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="复制命令"></p>
<p>其中那个“唯一表示密钥”是自动生成的。然后同理让朋友在他自己电脑上下载nps的客户端并cmd运行命令。之后朋友只要在mc服务器的地址填上”127.0.0.1:2000”（默认端口是2000，可以自己换），就能访问到我本机开在127.0.0.1:25565的Minecraft服务器了。</p>
<p>现在带宽已经没问题了，但是朋友还是反馈很卡，也找不出原因，所以就暂时放弃了这个方案。</p>
<h3 id="阿里云不同实例内网互联-另一台服务器流量转发？"><a href="#阿里云不同实例内网互联-另一台服务器流量转发？" class="headerlink" title="阿里云不同实例内网互联+另一台服务器流量转发？"></a>阿里云不同实例内网互联+另一台服务器流量转发？</h3><p>因为阿里云所谓的1Mbps的带宽限制，只是公网下行带宽的限制，对其他带宽（比如上行带宽、或者内网带宽）是没有限制的。我和同学在不同的阿里云账号下各拥有一台阿里云服务器，并且在同地域（这意味着内网互联是免费的）。于是我就有了另一个思路，依然把Minecraft服务器开在一台云服务器上，但是一部分玩家的流量直连云服务器，另一部分玩家通过连接另一台闲置的云服务器，然后由闲置的云服务器把流量转发到Minecraft服务器。这样带宽就变成两台服务器加起来2Mbps了。</p>
<p>首先是探索了半天阿里云的内网互联，由于阿里云的业务一直变化，所以网上找到的教程全都过期了，只好去看阿里云官方的文档。</p>
<p>首先你要在专有网络–快速链接–高速通道，找到云企业网，然后创建云企业网实例。</p>
<p><img src="https://img-blog.csdnimg.cn/20200717105028243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="云企业网"></p>
<p>先把你自己账号下的实例绑定进去，之后照着阿里云文档操作。</p>
<p><a href="https://help.aliyun.com/document_detail/64648.html" target="_blank" rel="noopener">阿里云帮助文档</a></p>
<p>然后登陆同学的账号，进行企业网授权，详情查看搜索阿里云文档关于授权部分内容。之后再登陆你的账户把同学的实例加入企业网，这样两个实例就可以通网了。</p>
<p>之后，使用frp，把Minecraft服务器的25565端口映射到另一台服务器上（记得ip不要填公网ip，要填内网ip，这样才不会占用公网下行带宽），就可以了，具体不再赘述。你也可以配置服务器的防火墙规则或者使用Nginx做端口转发，也是可以的。</p>
<p>用frp的优点是他可以进行数据压缩，进一步减少了带宽。</p>
<p>总的来说，这个方案的效果还不错。</p>
<p>本文地址： <a href="https://www.chimaoshu.top/为1M小水管的Minecraft服务器加速/">https://www.chimaoshu.top/为1M小水管的Minecraft服务器加速/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>阿里云</tag>
        <tag>P2P</tag>
        <tag>frp</tag>
        <tag>nps</tag>
      </tags>
  </entry>
  <entry>
    <title>在win10自用机上使用Nginx+Docker部署bitwarden_rs</title>
    <url>/%E5%9C%A8win10%E8%87%AA%E7%94%A8%E6%9C%BA%E4%B8%8A%E4%BD%BF%E7%94%A8Nginx-Docker%E9%83%A8%E7%BD%B2bitwarden-rs/</url>
    <content><![CDATA[<h2 id="最初的想法"><a href="#最初的想法" class="headerlink" title="最初的想法"></a>最初的想法</h2><p>从很久之前就一直想要找到1Password的替代品，当时自己用AES256 + RSA2048的加密方式，写一个服务端和客户端，只能在终端黑窗口里面运行，总归没有这些成熟的产品用得爽。后来了解到了Bitwarden，想部署到服务器上，想了想不如部署到本机上吧，不然服务器一到期就一直得续费。原版的Bitwarden服务端的服务对象是比较广的，资源消耗也比较大，总归不是办法。后来了解到Bitwarden_rs，是大佬用Rust重新写的一个不那么耗费资源的版本，就决定是它了。</p>
<a id="more"></a>

<h2 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h2><h3 id="首先是Bitwarden的部署"><a href="#首先是Bitwarden的部署" class="headerlink" title="首先是Bitwarden的部署"></a>首先是Bitwarden的部署</h3><p>首先需要在win10上安装Docker，不再赘述。<br>然后根据 <a href="https://github.com/dani-garcia/bitwarden_rs" target="_blank" rel="noopener">Github上官方给出的说明</a> ，只要打开命令行，输入下面命令就可以安装完成并部署到localhost中。</p>
<p>首先拉取镜像：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker pull bitwardenrs/server:latest</span><br></pre></td></tr></table></figure>
<p>然后是运行</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> -<span class="literal">-name</span> bitwarden <span class="literal">-v</span> /把这个路径换成你本机要存储的数据的绝对路径/:/<span class="keyword">data</span>/ <span class="literal">-p</span> <span class="number">80</span>:<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">80</span> bitwardenrs/server:latest</span><br></pre></td></tr></table></figure>
<p>如果要开启管理面板就加个参数，把上面命令换成这个：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> -<span class="literal">-name</span> bitwarden <span class="literal">-e</span> ADMIN_TOKEN=换成你的管理面板登陆密码 <span class="literal">-v</span> /把这个路径换成你本机要存储的数据的绝对路径/:/<span class="keyword">data</span>/ <span class="literal">-p</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">80</span>:<span class="number">80</span>  bitwardenrs/server:latest</span><br></pre></td></tr></table></figure>
<p>记得把路径换成你本机要存储这些密码数据的路径，如果不设置的话，你电脑一关机，数据就都没了。</p>
<p>当然你也可以把127.0.0.1:80:80中的”127.0.0.1:80”换成你要部署的本机ip的端口，如果想要部署在0.0.0.0（所有指向本机的ip）就直接输入80:80就好了。由于后面我要用Nginx进行反向代理，所以我是部署在了127.0.0.1。</p>
<p>只要你的Docker是正常的（包括网络连接正常），那么运行这两行命令之后，在浏览器访问<a href="http://localhost就可以正常访问到了。" target="_blank" rel="noopener">http://localhost就可以正常访问到了。</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200711095836893.png" alt="bitwarden"></p>
<p>现在你已经可以在本机使用Bitwarden的服务了，如果想让自己的手机或其他设备也安全地用上，请继续往下看。</p>
<h3 id="接下来是Nginx进行反向代理"><a href="#接下来是Nginx进行反向代理" class="headerlink" title="接下来是Nginx进行反向代理"></a>接下来是Nginx进行反向代理</h3><p>先到Nginx官网<a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a>上下载最新的适用于Windows的Nginx<br><img src="https://img-blog.csdnimg.cn/20200711102432429.png" alt="Nginx官网"><br><img src="https://img-blog.csdnimg.cn/20200711102552703.png" alt="Nginx下载"><br>下载Nginx压缩包之后找一个文件夹解压，我解压到了/bitwarden文件夹下。</p>
<p>然后再bitwarden/conf/目录下创建一个文件夹，命名为cert。</p>
<p>然后去给你的域名申请一个HTTPS证书，我是用了阿里云免费的证书，下载Nginx版本的证书（包含xxx.key和xxx.pem两个文件），然后把这两个文件放到cert下面。</p>
<p>然后编辑bitwarden/conf/nginx.conf 的配置，如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># HTTPS server</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl; <span class="comment">#SSL协议访问端口号为443。此处如未添加ssl，可能会造成Nginx无法启动。</span></span><br><span class="line">        <span class="attribute">server_name</span> localhost; <span class="comment">#将localhost修改为您证书绑定的域名，例如：www.example.com。</span></span><br><span class="line">        <span class="attribute">ssl_certificate</span> cert/domain name.pem; <span class="comment">#将domain name.pem替换成您证书的文件名。</span></span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> cert/domain name.key; <span class="comment">#将domain name.key替换成您证书的密钥文件名。</span></span><br><span class="line">        <span class="attribute">ssl_session_timeout</span> <span class="number">10s</span>;</span><br><span class="line">        <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; <span class="comment">#使用此加密套件。</span></span><br><span class="line">        <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>; <span class="comment">#使用该协议进行配置。</span></span><br><span class="line">        <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://localhost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后记得设置域名的解析记录，把你要的域名解析到你电脑的IP地址，之后就能通过域名进行https访问了。</p>
<p>我是解析到了我的内网IP地址，所以说我的手机需要和电脑连接同一个wifi才能访问到电脑的服务器。如果你想要让所有设备都能访问，那么可以用frp把你的电脑的443端口映射到云服务器上，同时把域名解析的ip设置你的云服务器的ip。（或者直接把bitwarden部署到你的云服务器上）</p>
<p>至此，已经可以使用https的方式，访问服务器了，部署已经完成。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>Bitwarden提供了多种客户端，有安卓、IOS的APP端、浏览器web端、浏览器插件、win、linux、macOS的桌面端、甚至还有好几个命令行的版本，全部可以从官网下载。<a href="https://bitwarden.com/#download" target="_blank" rel="noopener">https://bitwarden.com/#download</a></p>
<h2 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ProcessName</span> = <span class="string">"docker desktop"</span></span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">get-process</span> <span class="variable">$ProcessName</span> <span class="literal">-ErrorAction</span> SilentlyContinue) <span class="operator">-eq</span> <span class="variable">$Null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    echo <span class="string">"Docker is not running,strating...."</span> </span><br><span class="line">    start <span class="string">"Docker Desktop"</span></span><br><span class="line">    sleep <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">    echo <span class="string">"Process is running."</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">docker start bitwarden</span><br><span class="line">.\nginx</span><br></pre></td></tr></table></figure>

<p>将脚本保存为xxx..ps1，然后把这个脚本放到与Nginx.exe同目录下，把docker.exe的快捷方式也放到这个目录下（或者设置docker为开机启动）。</p>
<p>你可以把这个脚本设置为开机启动，你可以另外写一个run.bat</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">powershell .\run.ps1</span><br></pre></td></tr></table></figure>

<p>然后win+r，输入shell:startup后回车，打开控制开机自启动的文件目录，然后把这个bat的快捷方式放进去文件夹，之后开机就会自启动了。</p>
<h2 id="结束脚本"><a href="#结束脚本" class="headerlink" title="结束脚本"></a>结束脚本</h2><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">.\nginx -s stop</span><br><span class="line">docker stop <span class="number">822</span>faa38fd55</span><br><span class="line">choice /t <span class="number">2</span> /d y /n &gt;<span class="built_in">nul</span></span><br></pre></td></tr></table></figure>
<p>其中822faa38fd55指的是容器的ID（可以通过docker ps -a来查看容器的ID）<br>将脚本保存为xxx.bat</p>
<p>本文地址： <a href="https://www.chimaoshu.top/在win10自用机上使用Nginx-Docker部署bitwarden-rs/">https://www.chimaoshu.top/在win10自用机上使用Nginx-Docker部署bitwarden-rs/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>bitwarden</tag>
        <tag>Nginx</tag>
        <tag>reverse proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>关于win10下深信服sslvpn的客户端流量分流/不同网卡流量分流</title>
    <url>/%E5%85%B3%E4%BA%8E%E6%B7%B1%E4%BF%A1%E6%9C%8Dsslvpn%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E9%87%8F%E5%88%86%E6%B5%81/</url>
    <content><![CDATA[<p>​    如果你的单位或学校使用了深信服的sslvpn，有时候会有需要流量分流的场景，比如访问internet不直连而是走了sslvpn，比如sslvpn设定的路由策略与其他连接冲突导致无法上公网之类的问题。</p>
<p>踩了一下午坑，终于解决了问题。</p>
<p>​    解决的方法是修改路由表。通过修改路由表可以实现对不同的ip段走不同的连接模式。</p>
<a id="more"></a>

<p>​    如果你够细心的话，会发现用了深信服的vpn电脑会多了一个网络适配器<br><img src="https://pic.chimaoshu.top/imgs/2020/05/e83458ea7b3e6f93.png" alt="适配器"></p>
<p>理论上这个方法不止可以用于深信服的vpn，只要是多个网卡/网络适配器的分流都适用。</p>
<p>打开cmd，输入 ipconfig/all 查看你要分流的两个网卡/网络适配器的网关ip</p>
<p><img src="https://pic.chimaoshu.top/imgs/2020/05/18cfa245bb84a06e.png" alt="这个2开头的ip地址是虚拟的ip地址"></p>
<p>然后输入 route print -4 显示ipv4的路由规则</p>
<p><img src="https://pic.chimaoshu.top/imgs/2020/05/0ba81623e8b3ae78.png" alt="路由表"><br>可以看到路由表规定了不同的目标ip（包括目标的子网掩码）会走不同的网关，所以我们可以用<br>route add 和 route delete 命令对路由表进行删改，至于具体命令用法，百度一大堆，不再赘述，而且我也忘了。</p>
<p>本文地址： <a href="https://www.chimaoshu.top/关于深信服sslvpn的客户端流量分流/">https://www.chimaoshu.top/关于深信服sslvpn的客户端流量分流/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>深信服</tag>
        <tag>vpn</tag>
        <tag>分流</tag>
      </tags>
  </entry>
  <entry>
    <title>filezilla配置ssl证书过程中出现&#39;Failed to load SSL Libraries&#39;、&#39;Cannot create certificate.Failed to initialize SSL library&#39;、&#39;Could not load certificate file: error:02001003:system library:fopen:No such process&#39;</title>
    <url>/filezilla%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%87%BA%E7%8E%B0-Failed-to-load-SSL-Libraries-%E3%80%81-Cannot-create-certificate-Failed-to-initialize-SSL-library-%E3%80%81-Could-not-load-certificate-file-error-02001003-system-library-fopen-No-such-process-0/</url>
    <content><![CDATA[<p>‘Failed to load SSL Libraries’<br>‘Cannot create certificate.Failed to initialize SSL library’</p>
<a id="more"></a>

<p>以上两个问题的解决方法：<br>1.系统更新<br>2.卸载干净，然后从官网下载安装最新的版本<br>3.不要用中文版的filezilla server</p>
<p>‘Could not load certificate file: error:02001003:system library:fopen:No such process (0)’<br>解决方法：<br>1.检查证书所在文件夹是否有赋予足够的用户权限<br>2.以管理员身份运行filezilla server<br>3.证书的存放路径不要有中文</p>
<p>本文地址： <a href="https://www.chimaoshu.top/filezilla配置ssl证书过程中出现-Failed-to-load-SSL-Libraries-、-Cannot-create-certificate-Failed-to-initialize-SSL-library-、-Could-not-load-certificate-file-error-02001003-system-library-fopen-No-such-process-0/">https://www.chimaoshu.top/filezilla配置ssl证书过程中出现-Failed-to-load-SSL-Libraries-、-Cannot-create-certificate-Failed-to-initialize-SSL-library-、-Could-not-load-certificate-file-error-02001003-system-library-fopen-No-such-process-0/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>坑</category>
      </categories>
      <tags>
        <tag>filezilla</tag>
        <tag>ssl</tag>
        <tag>certificate</tag>
      </tags>
  </entry>
  <entry>
    <title>ImportError cannot import name &#39;&#39;DerBitString&#39;&#39; from &#39;&#39;Crypto.Util.asn1&#39;&#39;</title>
    <url>/ImportError-cannot-import-name-DerBitString-from-Crypto-Util-asn1/</url>
    <content><![CDATA[<p>今天用到 PyCryptodome 模块的时候，当我用到了 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br></pre></td></tr></table></figure>
<p>的时候，出现了错误：<br>ImportError : cannot import name ‘’DerBitString’’ from ‘’Crypto.Util.asn1’’。<br>找到了<a href="http://program.dengshilong.org/2018/10/11/%E6%97%A0%E6%B3%95%E5%AF%BC%E5%85%A5DerBitString%E9%94%99%E8%AF%AF/" target="_blank" rel="noopener">这篇博客</a>和<a href="https://pycryptodome.readthedocs.io/en/latest/src/faq.html#why-do-i-get-the-error-no-module-named-crypto-on-windows" target="_blank" rel="noopener">官方文档</a>，都提到了Windows下同时安装PyCryptodome和PyCrypto会出现这个问题。</p>
<a id="more"></a>

<p>给出的解决方案是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pip uninstall crypto</span><br><span class="line">pip uninstall pycryptodome</span><br><span class="line">pip install pycryptodome</span><br></pre></td></tr></table></figure>
<p>但我并没有安装crypto模块也出现了问题，后来发现只要</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pip uninstall pycryptodome</span><br><span class="line">pip install pycryptodome</span><br></pre></td></tr></table></figure>
<p>重新装一下pycryptodome问题就解决了。</p>
<p>本文地址： <a href="https://www.chimaoshu.top/ImportError-cannot-import-name-DerBitString-from-Crypto-Util-asn1/">https://www.chimaoshu.top/ImportError-cannot-import-name-DerBitString-from-Crypto-Util-asn1/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>坑</category>
      </categories>
      <tags>
        <tag>DerBitString</tag>
        <tag>PyCryptodome</tag>
        <tag>importError</tag>
      </tags>
  </entry>
  <entry>
    <title>（详细）基于frp与v2ray的几种校园网内网穿透的方案</title>
    <url>/%EF%BC%88%E8%AF%A6%E7%BB%86%E7%89%88%EF%BC%89%E5%9F%BA%E4%BA%8Efrp%E4%B8%8Ev2ray%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E7%9A%84%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>非零基础请移步<a href="\（简略版）基于frp与v2ray的几种校园网内网穿透的方案\">（简略版）基于frp与v2ray的几种校园网内网穿透的方案</a></p>
<p><a href="#0">设备</a></p>
<p><a href="#1">方案一:简单的frp socks5/http代理</a></p>
<p><a href="#2">方案二：用frp映射v2ray的inbound端口+校外设备http/socks5代理</a></p>
<p><a href="#3">方案三：用frp映射v2ray的inbound端口+校外设备使用v2ray/ssr连接</a></p>
<p><a href="#4">方案四：用v2ray自带的反向代理功能</a></p>
<p><a href="#5">方案五：用路由器代替校内主机</a></p>
<a id="more"></a>

<h1 id= '0'> 设备 </h1>

<h2 id="通讯过程的三台设备："><a href="#通讯过程的三台设备：" class="headerlink" title="通讯过程的三台设备："></a>通讯过程的三台设备：</h2><h3 id="A-校内跳板机，电脑路由器之类的设备，前提是能够访问校外网络。"><a href="#A-校内跳板机，电脑路由器之类的设备，前提是能够访问校外网络。" class="headerlink" title="A.校内跳板机，电脑路由器之类的设备，前提是能够访问校外网络。"></a>A.校内跳板机，电脑路由器之类的设备，前提是能够访问校外网络。</h3><h3 id="B-一台拥有公网ip的设备，一般是VPS云主机之类的"><a href="#B-一台拥有公网ip的设备，一般是VPS云主机之类的" class="headerlink" title="B.一台拥有公网ip的设备，一般是VPS云主机之类的"></a>B.一台拥有公网ip的设备，一般是VPS云主机之类的</h3><h3 id="C-任意想要在校外访问校园网的设备"><a href="#C-任意想要在校外访问校园网的设备" class="headerlink" title="C.任意想要在校外访问校园网的设备"></a>C.任意想要在校外访问校园网的设备</h3><p><img src="https://img-blog.csdnimg.cn/20200311224941794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="示意图"></p>
<h1 id= '1'> 方案一:简单的frp socks5/http代理</h1>


<p><a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">frp在github的下载地址</a></p>
<p>以Windows为例</p>
<p>下载后解压<br>把frps.exe和frps.ini拷贝到你拥有公网ip的主机。<br>把frpc.exe和frpc.ini拷贝到校内的主机。<br>顾名思义，s就是server，c就是client。</p>
<p>在云主机上进行frps.ini配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 12345(填写你要用来和校内主机建立连接的端口，注意检查防火墙）</span><br><span class="line">token = 8d283ya2-7sl5-4a8d-857e （相当于密码，要与frpc.ini中的token保持一致）</span><br></pre></td></tr></table></figure>
<p>这是最简单配置，更多配置请戳<a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="noopener"> frp官方中文文档</a></p>
<p>运行frps：<br>打开cmd，切换到frps.exe所在的目录，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frps.exe -c frps.ini</span><br></pre></td></tr></table></figure>

<p>出现以下文字则启动成功<br><img src="https://img-blog.csdnimg.cn/20200312111727240.png" alt="启动成功"><br>然后在校内跳板机配置frpc.ini：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 12.34.56.78（上面配置frps的主机的公网ip）</span><br><span class="line">server_port = 12345 （上面的bind_port填哪个这里就填哪个）</span><br><span class="line">token = 8d283ya2-7sl5-4a8d-857e（与上面token保持一致）</span><br><span class="line">pool_count = 5 （与服务端通信时预设的连接池数量，如果对连接速度有要求可以设大一些）</span><br><span class="line"></span><br><span class="line">[socks5_proxy]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">remote_port = 8080 （设置远程云主机的8080端口为监听端口，可供校外机器连接）</span><br><span class="line">plugin = socks5</span><br><span class="line">use_encryption = <span class="literal">true</span> （加  密  通  讯）</span><br><span class="line"><span class="comment">#如果不想设置用户名密码就把下面两行删掉，因为有的浏览器不支持身份认证</span></span><br><span class="line">plugin_http_user = xxx （用户名）</span><br><span class="line">plugin_http_passwd = xxxxxx （密码）</span><br></pre></td></tr></table></figure>
<p>如果不想要socks5代理，也可以换成http代理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 12.34.56.78（上面配置frps的主机的公网ip）</span><br><span class="line">server_port = 12345 （上面的bind_port填哪个这里就填哪个）</span><br><span class="line">token = 8d283ya2-7sl5-4a8d-857e（与上面token保持一致）</span><br><span class="line">pool_count = 5 （与服务端通信时预设的连接池数量，如果对连接速度有要求可以设大一些）</span><br><span class="line"></span><br><span class="line">[http_proxy]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">remote_port = 8080（设置远程云主机的8080端口为监听端口，可供校外机器连接）</span><br><span class="line">plugin = http_proxy</span><br><span class="line">use_encryption = <span class="literal">true</span> （加  密  通  讯）</span><br><span class="line"><span class="comment">#如果不想设置用户名密码就把下面两行删掉，因为有的浏览器不支持身份认证</span></span><br><span class="line">plugin_http_user = xxx</span><br><span class="line">plugin_http_passwd = xxxx</span><br></pre></td></tr></table></figure>
<p>比较鸡肋的就是<br>frp的http_proxy好像只能访问http，不能访问https网站</p>
<p>运行frpc:<br>打开cmd，切换到frpc.exe所在的目录，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure>
<p>出现以下文字则连接成功：<br><img src="https://img-blog.csdnimg.cn/20200312114900133.png" alt="连接成功"><br>现在socks5代理/http代理已经搭建完成<br>只要在校外主机的浏览器设置代理就可以访问校内网络了：<br><img src="https://img-blog.csdnimg.cn/20200312115224804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="设置代理"><br>通讯过程：校外设备向云主机发送网络请求，然后云主机把请求交给校内设备代理，校内设备进行代理，通过云主机返回校外设备请求的内容。</p>
<h1 id= '2'>方案二：用frp映射v2ray的inbound端口+校外设备http/socks5代理</h1>


<p>该方案适用于校外设备无法使用v2ray的情况</p>
<p>值得一提的是，socks5的数据都是没有经过加密的明文数据，所以方案二与方案一并不被推荐</p>
<p>思路：在校内设备搭建一个v2ray的代理，将v2ray的inbound设为socks5流量，然后把这个inbound端口通过frp映射到云主机上。校外设备则通过socks5或http代理访问校内外。</p>
<p>仍然以Windows为例</p>
<p>首先云主机配置frps.ini:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 12345(填写你要用来和校内主机建立连接的端口，注意检查防火墙）</span><br><span class="line">token = 8d283ya2-7sl5-4a8d-857e （相当于密码，要与frpc.ini中的token保持一致）</span><br></pre></td></tr></table></figure>
<p>然后打开cmd，切换到frps.exe所在目录运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frps.exe -c frps.ini</span><br></pre></td></tr></table></figure>
<p>完成云主机的配置</p>
<p>然后是校内设备搭建v2ray与frp：<br>&emsp;&emsp;首先是v2ray:<br>&emsp;&emsp;&emsp;&emsp;<a href="https://github.com/2dust/v2rayN/releases/download/3.7/v2rayN-Core.zip" target="_blank" rel="noopener">github的v2rayN下载地址</a><br>&emsp;&emsp;&emsp;&emsp;然后在随意位置新建一个123.json，进行编辑：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">"inbounds"</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="string">"port"</span>: 10808, //填监听端口，自己决定</span><br><span class="line">     <span class="string">"protocol"</span>: <span class="string">"socks"</span>, </span><br><span class="line">     <span class="string">"sniffing"</span>: &#123;</span><br><span class="line">       <span class="string">"enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="string">"destOverride"</span>: [<span class="string">"http"</span>, <span class="string">"tls"</span>]</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="string">"settings"</span>: &#123;</span><br><span class="line">       <span class="string">"auth"</span>: <span class="string">"noauth"</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> ],</span><br><span class="line"> <span class="string">"outbounds"</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="string">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">     <span class="string">"settings"</span>: &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;&emsp;然后打开v2rayN.exe<br>&emsp;&emsp;&emsp;&emsp;左上角“服务器–添加自定义服务器”<br>   &emsp;&emsp;&emsp;&emsp;<img src="https://img-blog.csdnimg.cn/20200312132503537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="添加服务器"><br>&emsp;&emsp;&emsp;&emsp;然后选择刚才编辑的123.config导入，就能在列表看到导入的配置了<br>&emsp;&emsp;&emsp;&emsp;然后在右下角任务栏选择启动刚才配置的服务器<br>&emsp;&emsp;&emsp;&emsp;<img src="https://img-blog.csdnimg.cn/20200312133221411.png" alt="选择服务器"><br>&emsp;&emsp;&emsp;&emsp;然后选择”Http代理”，开启全局模式<br>&emsp;&emsp;&emsp;&emsp;之后可以看到v2ray的UI最下边的一行代理地址：<br><img src="https://img-blog.csdnimg.cn/20200312133500287.png" alt="代理地址"><br>&emsp;&emsp;现在v2ray配置完成了，接下来配置frpc.ini:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common] <span class="comment">#common和前面的一样，不再赘述</span></span><br><span class="line">server_addr = 12.34.56.78</span><br><span class="line">server_port = 12345</span><br><span class="line">token = 8d283ya2-6dba-4a8d</span><br><span class="line">pool_count = 5</span><br><span class="line"></span><br><span class="line">[v2ray_mapping]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">remote_port = 8083 <span class="comment">#你的云主机上可供校外设备挂代理的端口</span></span><br><span class="line">local_port = 10809 <span class="comment">#校内设备本地http的端口，参考上一张图</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;&emsp;然后一样是打开cmd切换到所在目录，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样frpc也配置完成。</p>
<p>在校内设备的配置完成,<br>接下来就是校外设备设置代理了：</p>
<p>以win10为例，打开系统代理设置<br>填入云主机的ip和http的端口<br><img src="https://img-blog.csdnimg.cn/20200312134652434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="win10设置"><br>就可以使用校内设备的代理了</p>
<p>当然，这样是整个系统使用校内代理，比较麻烦。</p>
<p>推荐用浏览器插件 <a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?hl=zh-CN" target="_blank" rel="noopener">SwitchyOmega</a><br>设置校园网专用的代理，如图：<br><img src="https://img-blog.csdnimg.cn/2020031213523693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后可以在auto switch中设置自动切换<br><img src="https://img-blog.csdnimg.cn/20200312135350737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="自动切换"><br>在访问校园网时会自动切换为使用刚才配置的代理。</p>
<h1 id= '3'>方案三：用frp映射v2ray的inbound端口+校外设备使用v2ray/ssr连接</h1>


<p>该方案适用于校外设备可以使用v2ray的情况。<br>校内设备和云主机的配置过程和上述方案二大同小异。</p>
<p>其中v2ray的123.json配置需要换为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"inbounds"</span>: [</span><br><span class="line">  	//当然，v2ray也支持ssr。所以下面的这段配置也可以换成ssr配置</span><br><span class="line">  	//然后校外设备就可以用ssr连接</span><br><span class="line">  	//由于我不懂ssr配置，所以就不放出来了</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"port"</span>: 10809, // 本地监听端口</span><br><span class="line">      <span class="string">"protocol"</span>: <span class="string">"vmess"</span>,   </span><br><span class="line">      <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"clients"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"id"</span>: <span class="string">"123456"</span>,  // 用户ID（相当于ssr中的密码），客户端与服务器只要保持相同即可</span><br><span class="line">            <span class="string">"alterId"</span>: 64 //客户端与服务端须保持相同</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"outbounds"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"protocol"</span>: <span class="string">"freedom"</span>,  // 传出协议</span><br><span class="line">      <span class="string">"settings"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他的都一样</p>
<p>最后是校外设备设置代理，以Windows为例：<br>打开v2rayN.exe，然后左上角”服务器–添加vmess服务器”，<br>填写参数：<br><img src="https://img-blog.csdnimg.cn/20200312142508878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="添加VMess"><br>点击确定即可。<br>然后是安卓，先<a href="https://github.com/2dust/v2rayNG/releases" target="_blank" rel="noopener">v2rayNG github下载</a>，然后也是一样的配置。</p>
<h1 id= '4'>方案四：用v2ray自带的反向代理功能</h1>


<p>我没有试过这种方案，所以只能放个<a href="https://toutyrater.github.io/app/reverse2.html" target="_blank" rel="noopener">文档链接</a></p>
<p>该方案需要三方设备都使用v2ray</p>
<h1 id= '5'>方案五：用路由器代替校内主机</h1>


<p>众所周知，路由器可以刷各种固件。有些固件比如梅林或者老毛子之类的本身就自带v2ray和frp。<br>放假回家如果在校内没有跳板机，不妨试试路由器。<br>网上可以找到很多刷固件的教程。</p>
<p>接下来以老毛子为例进行说明。</p>
<p>首先校内的路由器必须要能上校外网络，很多学校是使用drcom的，对于drcom登录的，可以参考<a href="https://www.right.com.cn/forum/thread-215978-1-1.html" target="_blank" rel="noopener">这篇文章</a></p>
<p>或者直接ssh路由器，然后运行某些登录脚本。</p>
<p>frp设置和前面的没什么不同，路由器可以充当frpc或者frps，我们要让路由器充当frpc。</p>
<p>frp设置：<br>勾选“启动frpc客户端”，后面配置和前面的一样<br><img src="https://img-blog.csdnimg.cn/20200312151058521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="frp"><br>v2ray配置：<br>开启透明代理，设置透明代理窗口1099<br>（如果你这个路由器不想用于平时上网，可以不用勾选）<br><img src="https://img-blog.csdnimg.cn/20200312151236279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="v2ray"><br>然后进行config.json的配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"inbounds"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      //这个是透明代理的inbound，平时连路由器上网的流量走这里</span><br><span class="line">      <span class="string">"tag"</span>: <span class="string">"transparent"</span>,</span><br><span class="line">      <span class="string">"port"</span>: 1099,</span><br><span class="line">      <span class="string">"protocol"</span>: <span class="string">"dokodemo-door"</span>,</span><br><span class="line">      <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"network"</span>: <span class="string">"tcp,udp"</span>,</span><br><span class="line">        <span class="string">"followRedirect"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"sniffing"</span>: &#123;</span><br><span class="line">        <span class="string">"enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"destOverride"</span>: [<span class="string">"http"</span>, <span class="string">"tls"</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"streamSettings"</span>: &#123;</span><br><span class="line">        <span class="string">"sockopt"</span>: &#123;</span><br><span class="line">          <span class="string">"tproxy"</span>: <span class="string">"tproxy"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      //这个是校外跳进来的inbound，校外的流量走这里</span><br><span class="line">      <span class="string">"tag"</span>: <span class="string">"vmess-mapping"</span>,</span><br><span class="line">      <span class="string">"port"</span>: 10809, // 本地监听端口</span><br><span class="line">      <span class="string">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">      <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"clients"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"id"</span>: <span class="string">"123456"</span>, // 用户ID（相当于ssr中的密码），客户端与服务器只要保持相同即可</span><br><span class="line">            <span class="string">"alterId"</span>: 64 //客户端与服务端须保持相同</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"outbounds"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">      <span class="string">"settings"</span>: &#123;&#125;,</span><br><span class="line">      <span class="string">"tag"</span>: <span class="string">"direct"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      //如果这个路由器还想用于平时上网，</span><br><span class="line">      //可以自行添加自己平时  上    网  的配置，</span><br><span class="line">      //然后在rules里面添加路由规则</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"routing"</span>: &#123;</span><br><span class="line">    <span class="string">"domainStrategy"</span>: <span class="string">"IPOnDemand"</span>,</span><br><span class="line">    <span class="string">"rules"</span>: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这个路由器还想用于平时上网，<br>可以自行添加自己平时上网的服务器配置，<br>然后在rules里面添加路由规则。</p>
<h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1><p>本文地址： <a href="https://www.chimaoshu.top/（详细版）基于frp与v2ray的几种校园网内网穿透的方案/">https://www.chimaoshu.top/（详细版）基于frp与v2ray的几种校园网内网穿透的方案/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>frp</tag>
        <tag>v2ray</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>（简略）基于frp与v2ray的几种校园网内网穿透的方案</title>
    <url>/%EF%BC%88%E7%AE%80%E7%95%A5%E7%89%88%EF%BC%89%E5%9F%BA%E4%BA%8Efrp%E4%B8%8Ev2ray%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E7%9A%84%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>如果是零基础，请移步<a href="\（详细版）基于frp与v2ray的几种校园网内网穿透的方案\">（详细版）基于frp与v2ray的几种校园网内网穿透的方案</a></p>
<p><a href="#1">方案一:简单的frp socks5/http代理</a></p>
<p><a href="#2">方案二：用frp映射v2ray的inbound端口+校外设备http/socks5代理</a></p>
<p><a href="#3">方案三：用frp映射v2ray的inbound端口+校外设备使用v2ray/ssr连接</a></p>
<p><a href="#4">方案四：用v2ray自带的反向代理功能</a></p>
<p><a href="#5">方案五：用路由器代替校内主机</a></p>
<a id="more"></a>

<h3 id="通讯过程的三台设备："><a href="#通讯过程的三台设备：" class="headerlink" title="通讯过程的三台设备："></a>通讯过程的三台设备：</h3><h4 id="A-校内跳板机，电脑路由器之类的设备，前提是能够访问校外网络。"><a href="#A-校内跳板机，电脑路由器之类的设备，前提是能够访问校外网络。" class="headerlink" title="A.校内跳板机，电脑路由器之类的设备，前提是能够访问校外网络。"></a>A.校内跳板机，电脑路由器之类的设备，前提是能够访问校外网络。</h4><h4 id="B-一台拥有公网ip的设备，一般是VPS云主机之类的"><a href="#B-一台拥有公网ip的设备，一般是VPS云主机之类的" class="headerlink" title="B.一台拥有公网ip的设备，一般是VPS云主机之类的"></a>B.一台拥有公网ip的设备，一般是VPS云主机之类的</h4><h4 id="C-任意想要在校外访问校园网的设备"><a href="#C-任意想要在校外访问校园网的设备" class="headerlink" title="C.任意想要在校外访问校园网的设备"></a>C.任意想要在校外访问校园网的设备</h4><p><img src="https://img-blog.csdnimg.cn/20200311224941794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="示意图"></p>
<h1 id='1'> 方案一:简单的frp socks5/http代理 </h1>


<p>VPS（frps.ini）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 12345(要用来和校内主机建立连接的端口，注意检查防火墙）</span><br><span class="line">token = 8d283ya2-7sl5-4a8d-857e （相当于密码，要与frpc.ini中的token保持一致）</span><br></pre></td></tr></table></figure>
<p>然后启动frps</p>
<p>跳板机：(frpc.ini)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 12.34.56.78（公网ip）</span><br><span class="line">server_port = 12345 （上面的bind_port填哪个这里就填哪个）</span><br><span class="line">token = 8d283ya2-7sl5-4a8d-857e（与上面token保持一致）</span><br><span class="line">pool_count = 5 （与服务端通信时预设的连接池数量）</span><br><span class="line"></span><br><span class="line">[socks5_proxy]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">remote_port = 8080 （设置远程云主机的8080端口为监听端口，可供校外机器连接）</span><br><span class="line">plugin = socks5</span><br><span class="line">use_encryption = <span class="literal">true</span> </span><br><span class="line"><span class="comment">#如果不想设置用户名密码就把下面两行删掉，因为有的浏览器不支持身份认证</span></span><br><span class="line">plugin_http_user = xxx （用户名）</span><br><span class="line">plugin_http_passwd = xxxxxx （密码）</span><br></pre></td></tr></table></figure>
<p>如果不想要socks5代理，也可以换成http代理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 12.34.56.78（公网ip）</span><br><span class="line">server_port = 12345 （VPS端口，与上面一致）</span><br><span class="line">token = 8d283ya2-7sl5-4a8d-857e（与上面token保持一致）</span><br><span class="line">pool_count = 5 （与服务端通信时预设的连接池数量，如果对连接速度有要求可以设大一些）</span><br><span class="line"></span><br><span class="line">[http_proxy]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">remote_port = 8080</span><br><span class="line">plugin = http_proxy</span><br><span class="line">use_encryption = <span class="literal">true</span> </span><br><span class="line">plugin_http_user = xxx</span><br><span class="line">plugin_http_passwd = xxxx</span><br></pre></td></tr></table></figure>
<p>然后启动frps</p>
<p>比较鸡肋的就是，<br>frp自带的http_proxy好像只能访问http，不能访问https网站</p>
<p>之后只要在校外主机的浏览器设置代理就可以访问校内网络了：<br><img src="https://img-blog.csdnimg.cn/20200312115224804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="设置代理"></p>
<h1 id='2'> 方案二：用frp映射v2ray的inbound端口+校外设备http/socks5代理 </h1>


<p>该方案适用于校外设备无法使用v2ray的情况</p>
<p>值得一提的是，socks5的数据都是没有经过加密的明文数据，所以方案二与方案一并不被推荐</p>
<p>思路：在校内设备搭建一个v2ray的代理，将v2ray的inbound设为socks5流量，然后把这个inbound端口通过frp映射到云主机上。校外设备则通过socks5或http代理访问校内外。</p>
<p>frps.ini:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 12345</span><br><span class="line">token = 8d283ya2-7sl5-4a8d-857e</span><br></pre></td></tr></table></figure>


<p>然后是校内设备搭建v2ray与frp：</p>
<p>配置一个json</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"inbounds"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"port"</span>: 10808, //填监听端口</span><br><span class="line">        <span class="string">"protocol"</span>: <span class="string">"socks"</span>, </span><br><span class="line">        <span class="string">"sniffing"</span>: &#123;</span><br><span class="line">        <span class="string">"enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"destOverride"</span>: [<span class="string">"http"</span>, <span class="string">"tls"</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"auth"</span>: <span class="string">"noauth"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"outbounds"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">        <span class="string">"settings"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后打开v2rayN.exe<br>左上角“服务器–添加自定义服务器”</p>
<p>然后选择刚才编辑的json导入，开启<br>开启全局代理</p>
<p>查看界面最下边的监听端口：<br><img src="https://img-blog.csdnimg.cn/20200312133500287.png" alt="代理地址"></p>
<p>现在v2ray配置完成了，接下来配置frpc.ini:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 12.34.56.78//公网ip</span><br><span class="line">server_port = 12345 //端口</span><br><span class="line">token = 8d283ya2-6dba-4a8d</span><br><span class="line">pool_count = 5</span><br><span class="line"></span><br><span class="line">[v2ray_mapping]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">remote_port = 8083 <span class="comment">#供校外设备挂代理的端口</span></span><br><span class="line">local_port = 10809 <span class="comment">#校内设备本地http的端口，参考上一张图</span></span><br></pre></td></tr></table></figure>
<p>然后启动frpc</p>
<p>在校内设备的配置完成,<br>接下来就是校外设备设置代理了：</p>
<p>设置校园网专用的代理，如图：<br><img src="https://img-blog.csdnimg.cn/2020031213523693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>然后可以在auto switch中设置自动切换</p>
<p><img src="https://img-blog.csdnimg.cn/20200312135350737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="自动切换"><br>在访问校园网时会自动切换为校园代理。</p>
<h1 id='3'> 方案三：用frp映射v2ray的inbound端口+校外设备使用v2ray/ssr连接 </h1>

<p>该方案适用于校外设备可以使用v2ray的情况。<br>校内设备和云主机的配置过程和上述方案二大同小异。</p>
<p>其中v2ray的json配置需要换为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"inbounds"</span>: [</span><br><span class="line">  	//v2ray也支持ssr 所以下面的这段配置也可以换成ssr配置</span><br><span class="line">  	//然后校外设备就可以用ssr连接</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"port"</span>: 10809, // 本地监听端口</span><br><span class="line">      <span class="string">"protocol"</span>: <span class="string">"vmess"</span>,   </span><br><span class="line">      <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"clients"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"id"</span>: <span class="string">"123456"</span>,  // 用户ID（相当于ssr中的密码），客户端与服务器只要保持相同即可</span><br><span class="line">            <span class="string">"alterId"</span>: 64 //客户端与服务端须保持相同</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"outbounds"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"protocol"</span>: <span class="string">"freedom"</span>,  // 传出协议</span><br><span class="line">      <span class="string">"settings"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他的都一样</p>
<p>最后是校外设备设置代理，以Windows为例：<br>打开v2rayN.exe，然后左上角”服务器–添加vmess服务器”，<br>填写参数：<br><img src="https://img-blog.csdnimg.cn/20200313105352884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id='4'> 方案四：用v2ray自带的反代功能 </h1>


<p>我没有尝试过这种方案，只能放个<a href="https://toutyrater.github.io/app/reverse2.html" target="_blank" rel="noopener">文档链接</a><br>这个方案需要三方设备都使用v2ray</p>
<h1 id='5'> 方案五：用路由器代替校内主机 </h1>


<p>众所周知，路由器可以刷各种固件，有些固件本身就自带v2ray和frp<br>如果在校内没有跳板机，不妨试试路由器。<br>网上可以找到很多刷固件的教程。</p>
<p>接下来以老毛子为例进行说明。</p>
<p>首先校内的路由器必须要能上校外网络，很多学校是使用drcom的，对于drcom登录的，可以参考<a href="https://www.right.com.cn/forum/thread-215978-1-1.html" target="_blank" rel="noopener">这篇文章</a></p>
<p>或者ssh进路由器然后运行一些自动登录的脚本</p>
<p>frp设置和前面的没什么不同，路由器可以充当frpc或者frps，我们要让路由器充当frpc。</p>
<p>frp设置：<br>勾选“启动frpc客户端”，后面配置和前面的一样</p>
<p><img src="https://img-blog.csdnimg.cn/20200312151058521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="frp"></p>
<p>v2ray配置：<br>开启透明代理，设置透明代理端口1099</p>
<p>（如果这个路由器不想用于平时上网，可以不用勾选）<br><img src="https://img-blog.csdnimg.cn/20200312151236279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzY21z,size_16,color_FFFFFF,t_70" alt="v2ray"><br>然后进行config.json的配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"inbounds"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      //这个是透明代理的inbound，平时连路由器上网的流量走这里</span><br><span class="line">      <span class="string">"tag"</span>: <span class="string">"transparent"</span>,</span><br><span class="line">      <span class="string">"port"</span>: 1099,</span><br><span class="line">      <span class="string">"protocol"</span>: <span class="string">"dokodemo-door"</span>,</span><br><span class="line">      <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"network"</span>: <span class="string">"tcp,udp"</span>,</span><br><span class="line">        <span class="string">"followRedirect"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"sniffing"</span>: &#123;</span><br><span class="line">        <span class="string">"enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"destOverride"</span>: [<span class="string">"http"</span>, <span class="string">"tls"</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"streamSettings"</span>: &#123;</span><br><span class="line">        <span class="string">"sockopt"</span>: &#123;</span><br><span class="line">          <span class="string">"tproxy"</span>: <span class="string">"tproxy"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      //这个是校外跳进来的inbound，校外的流量走这里</span><br><span class="line">      <span class="string">"tag"</span>: <span class="string">"vmess-mapping"</span>,</span><br><span class="line">      <span class="string">"port"</span>: 10809, // 本地监听端口</span><br><span class="line">      <span class="string">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">      <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"clients"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"id"</span>: <span class="string">"123456"</span>, // 用户ID（相当于ssr中的密码），客户端与服务器只要保持相同即可</span><br><span class="line">            <span class="string">"alterId"</span>: 64 //客户端与服务端须保持相同</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"outbounds"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">      <span class="string">"settings"</span>: &#123;&#125;,</span><br><span class="line">      <span class="string">"tag"</span>: <span class="string">"direct"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      //如果这个路由器还想用于平时上网，</span><br><span class="line">      //可以自行添加自己平时kx上网的配置，</span><br><span class="line">      //然后在rules里面添加路由规则</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"routing"</span>: &#123;</span><br><span class="line">    <span class="string">"domainStrategy"</span>: <span class="string">"IPOnDemand"</span>,</span><br><span class="line">    <span class="string">"rules"</span>: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这个路由器还想用于平时上网，<br>可以自行添加自己平时上网的服务器配置，<br>然后在rules里面添加路由规则。</p>
<p>本文地址： <a href="https://www.chimaoshu.top/（简略版）基于frp与v2ray的几种校园网内网穿透的方案/">https://www.chimaoshu.top/（简略版）基于frp与v2ray的几种校园网内网穿透的方案/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>frp</tag>
        <tag>v2ray</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>myfirstpage</title>
    <url>/myfirstpage/</url>
    <content><![CDATA[<p>my first page</p>
<p>本文地址： <a href="https://www.chimaoshu.top/myfirstpage/">https://www.chimaoshu.top/myfirstpage/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<p>本文地址： <a href="https://www.chimaoshu.top/hello-world/">https://www.chimaoshu.top/hello-world/</a> <br>版权声明：本博客所有文章除特别声明外，均采用 Apache License 2.0 许可协议，转载请注明出处。</p>
]]></content>
  </entry>
</search>
